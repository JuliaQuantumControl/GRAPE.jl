var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [GRAPE]","category":"page"},{"location":"api/#GRAPE.GradGenerator","page":"API","title":"GRAPE.GradGenerator","text":"Extended generator for the standard dynamic gradient.\n\nGG = GradGenerator(G)\n\ncontains the original generator G (a Hamiltonian or Liouvillian) in GG.G, a vector of control generators Gϵᵢ (static operators for linear controls, and functions for non-linear controls) in GG.control_generators, and the controls in GG.controls.\n\nFor a generator G = H = H₀ + ϵ₁(t) H₁ +  +  ϵₙ(t) Hₙ, this extended generator encodes the block-matrix\n\nG = beginpmatrix\n    H       0  dots   0  H₁   \n    0       H  dots   0  H₂   \n    vdots     ddots    vdots \n    0       0  dots   H  Hₙ    \n    0       0  dots   0  H\nendpmatrix\n\n\n\n\n\n","category":"type"},{"location":"api/#GRAPE.GradVector","page":"API","title":"GRAPE.GradVector","text":"Extended state-vector for the dynamic gradient.\n\nΨ̃ = GradVector(Ψ, G̃)\n\nfor a state Ψ and a GradGenerator G̃ contains the original Ψ in Ψ̃.state and storage for n gradient-states for the n controls in G̃ in Ψ̃.grad_states.\n\nThe GradVector conceptually corresponds to a direct-sum (block) column-vector Ψ = (Ψ₁ Ψ₂  Ψₙ Ψ)^T. With a G as in the documentation of GradGenerator, we have\n\nG Ψ = beginpmatrix\nH Ψ₁ + H₁Ψ \nvdots \nH Ψₙ + HₙΨ \nH Ψ\nendpmatrix\n\nand\n\ne^-i G dt beginpmatrix 0  vdots  0  Ψ endpmatrix\n= beginpmatrix\nfracϵ₁ e^-i H dt Ψ \nvdots \nfracϵₙ e^-i H dt Ψ \ne^-i H dt Ψ\nendpmatrix\n\n\n\n\n\n","category":"type"},{"location":"api/#GRAPE._bw_prop!-NTuple{5, Any}","page":"API","title":"GRAPE._bw_prop!","text":"Backwards propagate the states ϕ and store them\n\n\n\n\n\n","category":"method"},{"location":"api/#GRAPE._fw_prop!-NTuple{7, Any}","page":"API","title":"GRAPE._fw_prop!","text":"Propagate system forward in time and store states at a constant objective index\n\n\n\n\n\n","category":"method"},{"location":"api/#GRAPE._fw_prop_aux!-NTuple{11, Any}","page":"API","title":"GRAPE._fw_prop_aux!","text":"Propagate auxilliary system forward in time and then store the states at a constant objective index\n\n\n\n\n\n","category":"method"},{"location":"overview/#Overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"examples/#Examples","page":"List of Examples","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"List of Examples","title":"List of Examples","text":"Pages = [\n    \"simple_state_to_state.md\",\n]\nDepth = 1","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"EditURL = \"https://github.com/JuliaQuantumControl/GRAPE.jl/blob/master/examples/simple_state_to_state.jl\"","category":"page"},{"location":"examples/simple_state_to_state/#Example-1:-Optimization-of-a-State-to-State-Transfer-in-a-Two-Level-System","page":"Example 1 (TLS)","title":"Example 1: Optimization of a State-to-State Transfer in a Two-Level-System","text":"","category":"section"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"tip: Tip\nThis example is also available as a Jupyter notebook: simple_state_to_state.ipynb.Compare this example against the same example using the krotov Python package.","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"gdefop1hat1 gdefinittextinit gdeftgttexttgt","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"This first example illustrates the basic use of the Krotov.jl by solving a simple canonical optimization problem: the transfer of population in a two level system.","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"using QuantumControl\nusing LinearAlgebra","category":"page"},{"location":"examples/simple_state_to_state/#Two-level-Hamiltonian","page":"Example 1 (TLS)","title":"Two-level Hamiltonian","text":"","category":"section"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"We consider the Hamiltonian opH_0 = - fracomega2 opsigma_z, representing a simple qubit with energy level splitting omega in the basis ket0ket1. The control field epsilon(t) is assumed to couple via the Hamiltonian opH_1(t) = epsilon(t) opsigma_x to the qubit, i.e., the control field effectively drives transitions between both qubit states.","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"We we will use","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"ϵ(t) = 0.2 * QuantumControl.shapes.flattop(t, T = 5, t_rise = 0.3, func = :blackman);\nnothing #hide","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"\"\"\"Two-level-system Hamiltonian.\"\"\"\nfunction hamiltonian(Ω = 1.0, ϵ = ϵ)\n    σ̂_z = ComplexF64[1 0; 0 -1]\n    σ̂_x = ComplexF64[0 1; 1 0]\n    Ĥ₀ = -0.5 * Ω * σ̂_z\n    Ĥ₁ = σ̂_x\n    return (Ĥ₀, (Ĥ₁, ϵ))\nend;\nnothing #hide","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"H = hamiltonian();\nnothing #hide","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"The control field here switches on from zero at t=0 to it's maximum amplitude 0.2 within the time period 0.3 (the switch-on shape is half a Blackman pulse). It switches off again in the time period 0.3 before the final time T=5). We use a time grid with 500 time steps between 0 and T:","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"tlist = collect(range(0, 5, length = 500));\nnothing #hide","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"using PyPlot\nmatplotlib.use(\"Agg\")\n\nfunction plot_control(pulse::Vector, tlist)\n    fig, ax = matplotlib.pyplot.subplots(figsize = (6, 3))\n    ax.plot(tlist, pulse)\n    ax.set_xlabel(\"time\")\n    ax.set_ylabel(\"amplitude\")\n    return fig\nend\n\nplot_control(ϵ::T, tlist) where {T<:Function} = plot_control([ϵ(t) for t in tlist], tlist)\n\nplot_control(H[2][2], tlist)","category":"page"},{"location":"examples/simple_state_to_state/#Optimization-target","page":"Example 1 (TLS)","title":"Optimization target","text":"","category":"section"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"The krotov package requires the goal of the optimization to be described by a list of Objective instances. In this example, there is only a single objective: the state-to-state transfer from initial state ketPsi_init = ket0 to the target state ketPsi_tgt = ket1, under the dynamics of the Hamiltonian opH(t):","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"function ket(label)\n    result = Dict(\"0\" => Vector{ComplexF64}([1, 0]), \"1\" => Vector{ComplexF64}([0, 1]))\n    return result[string(label)]\nend;\nnothing #hide","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"objectives = [Objective(initial_state = ket(0), generator = H, target_state = ket(1))]","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"problem = ControlProblem(\n    objectives = objectives,\n    pulse_options = IdDict(\n        ϵ => Dict(\n            :lambda_a => 5,\n            :update_shape =>\n                t -> QuantumControl.shapes.flattop(\n                    t,\n                    T = 5,\n                    t_rise = 0.3,\n                    func = :blackman,\n                ),\n        ),\n    ),\n    tlist = tlist,\n    iter_stop = 50,\n    chi = QuantumControl.functionals.chi_ss!,\n    J_T = QuantumControl.functionals.J_T_ss,\n    check_convergence = res -> begin\n        ((res.J_T < 1e-3) && (res.converged = true) && (res.message = \"J_T < 10⁻³\"))\n    end,\n);\nnothing #hide","category":"page"},{"location":"examples/simple_state_to_state/#Simulate-dynamics-under-the-guess-field","page":"Example 1 (TLS)","title":"Simulate dynamics under the guess field","text":"","category":"section"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"Before running the optimization procedure, we first simulate the dynamics under the guess field epsilon_0(t). The following solves equation of motion for the defined objective, which contains the initial state ketPsi_init and the Hamiltonian opH(t) defining its evolution.","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"guess_dynamics = propagate(\n    objectives[1],\n    problem.tlist;\n    storage = true,\n    observables = (Ψ -> abs.(Ψ) .^ 2,),\n)","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"function plot_population(pop0::Vector, pop1::Vector, tlist)\n    fig, ax = matplotlib.pyplot.subplots(figsize = (6, 3))\n    ax.plot(tlist, pop0, label = \"0\")\n    ax.plot(tlist, pop1, label = \"1\")\n    ax.legend()\n    ax.set_xlabel(\"time\")\n    ax.set_ylabel(\"population\")\n    return fig\nend\n\nplot_population(guess_dynamics[1,:], guess_dynamics[2,:], tlist)","category":"page"},{"location":"examples/simple_state_to_state/#Optimize","page":"Example 1 (TLS)","title":"Optimize","text":"","category":"section"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"In the following we optimize the guess field epsilon_0(t) such that the intended state-to-state transfer ketPsi_init rightarrow ketPsi_tgt is solved, via the krotov package's central optimize_pulses routine.  It requires, besides the previously defined objectives, information about the optimization functional J_T (implicitly, via chi_constructor, which calculates the states ketchi = fracJ_TbraPsi).","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"opt_result = optimize(problem, method = :krotov);\nnothing #hide","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"opt_result","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"We can plot the optimized field:","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"plot_control(opt_result.optimized_controls[1], tlist)","category":"page"},{"location":"examples/simple_state_to_state/#Simulate-the-dynamics-under-the-optimized-field","page":"Example 1 (TLS)","title":"Simulate the dynamics under the optimized field","text":"","category":"section"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"Having obtained the optimized control field, we can simulate the dynamics to verify that the optimized field indeed drives the initial state ketPsi_init = ket0 to the desired target state ketPsi_tgt = ket1.","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"opt_dynamics = propagate(\n    objectives[1],\n    problem.tlist;\n    controls_map = IdDict(ϵ => opt_result.optimized_controls[1]),\n    storage = true,\n    observables = (Ψ -> abs.(Ψ) .^ 2,),\n)","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"plot_population(opt_dynamics[1,:], opt_dynamics[2,:], tlist)","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = GRAPE","category":"page"},{"location":"#GRAPE.jl","page":"Home","title":"GRAPE.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Julia implementation of Gradient Ascent Pulse engineering.","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"overview.md\",\n]\nDepth = 1","category":"page"},{"location":"#Examples","page":"Home","title":"Examples","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"examples/simple_state_to_state.md\",\n]\nDepth = 1","category":"page"},{"location":"#API","page":"Home","title":"API","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"api.md\",\n]\nDepth = 1","category":"page"}]
}
