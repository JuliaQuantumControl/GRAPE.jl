var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [GRAPE]","category":"page"},{"location":"api/#GRAPE.GrapeResult","page":"API","title":"GRAPE.GrapeResult","text":"Result object returned by optimize_grape.\n\n\n\n\n\n","category":"type"},{"location":"api/#GRAPE.optimize_grape-Tuple{Any}","page":"API","title":"GRAPE.optimize_grape","text":"Optimize a control problem using GRAPE.\n\nresult = optimize_grape(problem)\n\noptimizes the given control problem, returning a GrapeResult.\n\nnote: Note\nIt is recommended to call optimize with method=:GRAPE instead of calling optimize_grape directly.\n\nKeyword arguments that control the optimization are taken from the keyword arguments used in the instantiation of problem.\n\nRequired problem keyword arguments\n\nJ_T: A function J_T(ϕ, objectives, τ=τ) that evaluates the final time functional from a list ϕ of forward-propagated states and problem.objectives.\ngradient:  A function gradient!(G, τ, ∇τ) that stores the gradient of J_T in G.\n\nOptional problem keyword arguments\n\nupdate_hook: Not immplemented\ninfo_hook: A function that receives the same argumens as update_hook, in order to write information about the current iteration to the screen or to a file. The default info_hook prints a table with convergence information to the screen. Runs after update_hook. The info_hook function may return a tuple, which is stored in the list of records inside the GrapeResult object.\ncheck_convergence: A function to check whether convergence has been reached. Receives a GrapeResult object result, and should set result.converged to true and result.message to an appropriate string in case of convergence. Multiple convergence checks can be performed by chaining functions with ∘. The convergence check is performed after any calls to update_hook and info_hook.\nx_tol: Parameter for Optim.jl\nf_tol: Parameter for Optim.jl\ng_tol: Parameter for Optim.jl\nshow_trace: Parameter for Optim.jl\nextended_trace:  Parameter for Optim.jl\nshow_every: Parameter for Optim.jl\nallow_f_increases: Parameter for Optim.jl\noptimizer: An optional Optim.jl optimizer (Optim.AbstractOptimizer instance). If not given, an L-BFGS-B optimizer will be used.\nprop_method/fw_prop_method/bw_prop_method: The propagation method to use for each objective, see below.\nprop_method/fw_prop_method/grad_prop_method: The propagation method to use for the extended gradient vector for each objective, see below.\n\nThe propagation method for the forward propagation of each objective is determined by the first available item of the following:\n\na fw_prop_method keyword argument\na prop_method keyword argument\na property fw_prop_method of the objective\na property prop_method of the objective\nthe value :auto\n\nThe propagation method for the backword propagation is determined similarly, but with bw_prop_method instead of fw_prop_method. The propagation method for the forward propagation of the extended gradient vector for each objective is determined from grad_prop_method, fw_prop_method, prop_method in order of precedence.\n\n\n\n\n\n","category":"method"},{"location":"api/#GRAPE.print_table-Tuple{Any, Optim.OptimizationState, Optim.AbstractOptimizerState, Any, Vararg{Any}}","page":"API","title":"GRAPE.print_table","text":"Print optimization progress as a table.\n\nThis functions serves as the default info_hook for an optimization with GRAPE.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumControlBase.optimize-Tuple{Any, Val{:GRAPE}}","page":"API","title":"QuantumControlBase.optimize","text":"opt_result = optimize(problem; method=:GRAPE, kwargs...)\n\noptimizes problem using GRadident Ascent Pulse Engineering (GRAPE), see GRAPE.optimize_grape.\n\n\n\n\n\n","category":"method"},{"location":"history/#History","page":"History","title":"History","text":"","category":"section"},{"location":"history/#.1.0-(2022-02-14)","page":"History","title":"0.1.0 (2022-02-14)","text":"","category":"section"},{"location":"history/","page":"History","title":"History","text":"First public release","category":"page"},{"location":"overview/#Overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"examples/#Examples","page":"List of Examples","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"List of Examples","title":"List of Examples","text":"Pages = [\n    \"simple_state_to_state.md\",\n]\nDepth = 1","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"EditURL = \"https://github.com/JuliaQuantumControl/GRAPE.jl/blob/master/examples/simple_state_to_state.jl\"","category":"page"},{"location":"examples/simple_state_to_state/#Example-1:-Optimization-of-a-State-to-State-Transfer-in-a-Two-Level-System","page":"Example 1 (TLS)","title":"Example 1: Optimization of a State-to-State Transfer in a Two-Level-System","text":"","category":"section"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"tip: Tip\nThis example is also available as a Jupyter notebook: simple_state_to_state.ipynb.Compare this example against the same example using Krotov's method.","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"gdefop1hat1 gdefinittextinit gdeftgttexttgt","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"This first example illustrates the basic use of the GRAPE.jl by solving a simple canonical optimization problem: the transfer of population in a two level system.","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"using DrWatson\n@quickactivate \"GRAPETests\"","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"using QuantumControl","category":"page"},{"location":"examples/simple_state_to_state/#Two-level-Hamiltonian","page":"Example 1 (TLS)","title":"Two-level Hamiltonian","text":"","category":"section"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"We consider the Hamiltonian opH_0 = - fracomega2 opsigma_z, representing a simple qubit with energy level splitting omega in the basis ket0ket1. The control field epsilon(t) is assumed to couple via the Hamiltonian opH_1(t) = epsilon(t) opsigma_x to the qubit, i.e., the control field effectively drives transitions between both qubit states.","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"We we will use","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"ϵ(t) = 0.2 * QuantumControl.Shapes.flattop(t, T=5, t_rise=0.3, func=:blackman);\nnothing #hide","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"\"\"\"Two-level-system Hamiltonian.\"\"\"\nfunction hamiltonian(Ω=1.0, ϵ=ϵ)\n    σ̂_z = ComplexF64[\n        1  0\n        0 -1\n    ]\n    σ̂_x = ComplexF64[\n        0  1\n        1  0\n    ]\n    Ĥ₀ = -0.5 * Ω * σ̂_z\n    Ĥ₁ = σ̂_x\n    return (Ĥ₀, (Ĥ₁, ϵ))\nend;\nnothing #hide","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"H = hamiltonian();\nnothing #hide","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"The control field here switches on from zero at t=0 to it's maximum amplitude 0.2 within the time period 0.3 (the switch-on shape is half a Blackman pulse). It switches off again in the time period 0.3 before the final time T=5). We use a time grid with 500 time steps between 0 and T:","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"tlist = collect(range(0, 5, length=500));\nnothing #hide","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"using Plots\nPlots.default(\n    linewidth               = 3,\n    size                    = (550, 300),\n    legend                  = :right,\n    foreground_color_legend = nothing,\n    background_color_legend = RGBA(1, 1, 1, 0.8)\n)","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"function plot_control(pulse::Vector, tlist)\n    plot(tlist, pulse, xlabel=\"time\", ylabel=\"amplitude\", legend=false)\nend\n\nplot_control(ϵ::T, tlist) where {T<:Function} = plot_control([ϵ(t) for t in tlist], tlist);\nnothing #hide","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"fig = plot_control(H[2][2], tlist)","category":"page"},{"location":"examples/simple_state_to_state/#Optimization-target","page":"Example 1 (TLS)","title":"Optimization target","text":"","category":"section"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"First, we define a convenience function for the eigenstates.","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"function ket(label)\n    result = Dict(\"0\" => Vector{ComplexF64}([1, 0]), \"1\" => Vector{ComplexF64}([0, 1]))\n    return result[string(label)]\nend;\nnothing #hide","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"The physical objective of our optimization is to transform the initial state ket0 into the target state ket1 under the time evolution induced by the Hamiltonian opH(t).","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"objectives = [Objective(initial_state=ket(0), generator=H, target_state=ket(1))];\nnothing #hide","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"The full control problem includes this objective, information about the time grid for the dynamics, and the functional to be used (the square modulus of the overlap tau with the target state in this case).","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"problem = ControlProblem(\n    objectives=objectives,\n    tlist=tlist,\n    pulse_options=Dict(),\n    iter_stop=500,\n    J_T=QuantumControl.Functionals.J_T_sm,\n    gradient=QuantumControl.Functionals.grad_J_T_sm!,\n    check_convergence=res -> begin\n        ((res.J_T < 1e-3) && (res.converged = true) && (res.message = \"J_T < 10⁻³\"))\n    end,\n);\nnothing #hide","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"Note that we have given an explicit function that calculates the gradient partial J_Tpartial tau","category":"page"},{"location":"examples/simple_state_to_state/#Simulate-dynamics-under-the-guess-field","page":"Example 1 (TLS)","title":"Simulate dynamics under the guess field","text":"","category":"section"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"Before running the optimization procedure, we first simulate the dynamics under the guess field epsilon_0(t). The following solves equation of motion for the defined objective, which contains the initial state ketPsi_init and the Hamiltonian opH(t) defining its evolution.","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"guess_dynamics = propagate_objective(\n    objectives[1],\n    problem.tlist;\n    storage=true,\n    observables=(Ψ -> abs.(Ψ) .^ 2,)\n)","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"function plot_population(pop0::Vector, pop1::Vector, tlist)\n    fig = plot(tlist, pop0, label=\"0\", xlabel=\"time\", ylabel=\"population\")\n    plot!(fig, tlist, pop1; label=\"1\")\nend;\nnothing #hide","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"fig = plot_population(guess_dynamics[1, :], guess_dynamics[2, :], tlist)","category":"page"},{"location":"examples/simple_state_to_state/#Optimization-with-LBFGSB","page":"Example 1 (TLS)","title":"Optimization with LBFGSB","text":"","category":"section"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"In the following we optimize the guess field epsilon_0(t) such that the intended state-to-state transfer ketPsi_init rightarrow ketPsi_tgt is solved.","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"The GRAPE package performs the optimization by calculating the gradient of J_T with respect to the values of the control field at each point in time. This gradient is then fed into a backend solver that calculates an appropriate update based on that gradient.","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"By default, this backend is LBFGSB.jl, a wrapper around the true and tested L-BFGS-B Fortran library. L-BFGS-B is a pseudo-Hessian method: it efficiently estimates the second-order Hessian from the gradient information. The search direction determined from that Hessian dramatically improves convergence compared to using the gradient directly as a search direction. The L-BFGS-B method performs its own linesearch to determine how far to go in the search direction.","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"It can be quite instructive to see how the improvement in the pseudo-Hessian search direction compares to the gradient, how the linesearch finds an appropriate step width. For this purpose, we have a GRAPELinesearchAnalysis package that automatically generates plots in every iteration of the optimization showing the linesearch behavior","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"using GRAPELinesearchAnalysis","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"We feed this into the optimization as part of the info_hook.","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"opt_result_LBFGSB, file = @optimize_or_load(\n    datadir(\"TLS\"),\n    problem,\n    method = :grape,\n    filename = \"opt_result_LBFGSB.jld2\",\n    info_hook = chain_infohooks(\n        GRAPELinesearchAnalysis.plot_linesearch(datadir(\"TLS\", \"Linesearch\", \"LBFGSB\")),\n        QuantumControl.GRAPE.print_table,\n    )\n);\nnothing #hide","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"When going through this tutorial locally, the generated images for the linesearch can be found in docs/TLS/Linesearch/LBFGSB.","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"datadir(\"TLS\", \"Linesearch\", \"LBFGSB\")","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"opt_result_LBFGSB","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"We can plot the optimized field:","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"fig = plot_control(opt_result_LBFGSB.optimized_controls[1], tlist)","category":"page"},{"location":"examples/simple_state_to_state/#Optimization-with-Optim.jl","page":"Example 1 (TLS)","title":"Optimization with Optim.jl","text":"","category":"section"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"As an alternative to the default L-BFGS-B backend, we can also use any of the gradient-based optimizers in Optiml.jl. This also gives full control over the linesearch method.","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"using Optim\nusing LineSearches","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"Here, we use the LBFGS implementation that is part of Optim (which is not exactly the same as L-BFGS-B; \"B\" being the variant of LBFGS with optional additional bounds on the control) with a Hager-Zhang linesearch","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"opt_result_OptimLBFGS, file = @optimize_or_load(\n    datadir(\"TLS\"),\n    problem,\n    method = :grape,\n    filename = \"opt_result_OptimLBFGS.jld2\",\n    info_hook = chain_infohooks(\n        GRAPELinesearchAnalysis.plot_linesearch(datadir(\"TLS\", \"Linesearch\", \"OptimLBFGS\")),\n        QuantumControl.GRAPE.print_table,\n    ),\n    optimizer = Optim.LBFGS(;\n        alphaguess=LineSearches.InitialStatic(alpha=0.2),\n        linesearch=LineSearches.HagerZhang(alphamax=2.0)\n    )\n);\nnothing #hide","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"opt_result_OptimLBFGS","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"We can plot the optimized field:","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"fig = plot_control(opt_result_OptimLBFGS.optimized_controls[1], tlist)","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"We can see that the choice of linesearch parameters in particular strongly influence the convergence and the resulting field. Play around with different methods and parameters, and compare the different plots generated by GRAPELinesearchAnalysis!","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"Empirically, we find the default L-BFGS-B to have a very well-behaved linesearch.","category":"page"},{"location":"examples/simple_state_to_state/#Simulate-the-dynamics-under-the-optimized-field","page":"Example 1 (TLS)","title":"Simulate the dynamics under the optimized field","text":"","category":"section"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"Having obtained the optimized control field, we can simulate the dynamics to verify that the optimized field indeed drives the initial state ketPsi_init = ket0 to the desired target state ketPsi_tgt = ket1.","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"opt_dynamics = propagate_objective(\n    objectives[1],\n    problem.tlist;\n    controls_map=IdDict(ϵ => opt_result_LBFGSB.optimized_controls[1]),\n    storage=true,\n    observables=(Ψ -> abs.(Ψ) .^ 2,)\n)","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"fig = plot_population(opt_dynamics[1, :], opt_dynamics[2, :], tlist)","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = GRAPE","category":"page"},{"location":"#GRAPE.jl","page":"Home","title":"GRAPE.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Julia implementation of Gradient Ascent Pulse engineering.","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"overview.md\",\n]\nDepth = 1","category":"page"},{"location":"#Examples","page":"Home","title":"Examples","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"examples/simple_state_to_state.md\",\n]\nDepth = 1","category":"page"},{"location":"#API","page":"Home","title":"API","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"api.md\",\n]\nDepth = 1","category":"page"},{"location":"#History","page":"Home","title":"History","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"history.md\",\n]\nDepth = 1","category":"page"}]
}
