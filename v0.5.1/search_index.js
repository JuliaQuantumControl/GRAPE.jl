var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [GRAPE]","category":"page"},{"location":"api/#GRAPE.GrapeResult","page":"API","title":"GRAPE.GrapeResult","text":"Result object returned by optimize_grape.\n\n\n\n\n\n","category":"type"},{"location":"api/#GRAPE.optimize_grape-Tuple{Any}","page":"API","title":"GRAPE.optimize_grape","text":"Optimize a control problem using GRAPE.\n\nresult = optimize_grape(problem)\n\noptimizes the given control problem, by minimizing the functional\n\nJ(ϵ_ln) = J_T(ϕ_k(T)) + λ_a J_a(ϵ_ln)\n\nwhere the final time functional J_T depends explicitly on the forward-propagated states and the running cost J_a depends explicitly on pulse values ϵ_nl of the l'th control discretized on the n'th interval of the time grid.\n\nReturns a GrapeResult.\n\nnote: Note\nIt is recommended to call optimize with method=:GRAPE instead of calling optimize_grape directly.\n\nKeyword arguments that control the optimization are taken from the keyword arguments used in the instantiation of problem.\n\nRequired problem keyword arguments\n\nJ_T: A function J_T(ϕ, objectives; τ=τ) that evaluates the final time functional from a vector ϕ of forward-propagated states and problem.objectives. For all objectives that define a target_state, the element τₖ of the vector τ will contain the overlap of the state ϕₖ with the target_state of the k'th objective, or NaN otherwise.\n\nOptional problem keyword arguments\n\nchi: A function chi!(χ, ϕ, objectives) what receives a list ϕ of the forward propagated states and must set χₖ = -J_Tϕₖ. If not given, it will be automatically determined from J_T via make_chi with the default parameters.\nJ_a: A function J_a(pulsevals, tlist) that evaluates running costs over the pulse values, where pulsevals are the vectorized values ϵ_nl. If not given, the optimization will not include a running cost.\ngradient_method=:gradgen: One of :gradgen (default) or :taylor. With gradient_method=:gradgen, the gradient is calculated using QuantumGradientGenerators. With gradient_method=:taylor, it is evaluated via a Taylor series, see Eq. (20) in Kuprov and Rogers,  J. Chem. Phys. 131, 234108 (2009).\ntaylor_grad_max_order=100: If given with gradient_method=:taylor, the maximum number of terms in the Taylor series. If taylor_grad_check_convergence=true (default), if the Taylor series does not convergence within the given number of terms, throw an an error. With taylor_grad_check_convergence=true, this is the exact order of the Taylor series.\ntaylor_grad_tolerance=1e-16: If given with gradient_method=:taylor and taylor_grad_check_convergence=true, stop the Taylor series when the norm of the term falls below the given tolerance. Ignored if taylor_grad_check_convergence=false.\ntaylor_grad_check_convergence=true: If given as true (default), check the convergence after each term in the Taylor series an stop as soon as the norm of the term drops below the given number. If false, stop after exactly taylor_grad_max_order terms.\nlambda_a=1: A weight for the running cost J_a.\ngrad_J_a: A function to calculate the gradient of J_a. If not given, it will be automatically determined.\nupper_bound: An upper bound for the value of any optimized control. Time-dependent upper bounds can be specified via pulse_options.\nlower_bound: A lower bound for the value of any optimized control. Time-dependent lower bounds can be specified via pulse_options.\npulse_options: A dictionary that maps every control (as obtained by get_controls from the problem.objectives) to a dict with the following possible keys:\n:upper_bounds: A vector of upper bound values, one for each intervals of the time grid. Values of Inf indicate an unconstrained upper bound for that time interval, respectively the global upper_bound, if given.\n:lower_bounds: A vector of lower bound values. Values of -Inf indicate an unconstrained lower bound for that time interval,\nupdate_hook: Not implemented\ninfo_hook: A function that receives the same arguments as update_hook, in order to write information about the current iteration to the screen or to a file. The default info_hook prints a table with convergence information to the screen. Runs after update_hook. The info_hook function may return a tuple, which is stored in the list of records inside the GrapeResult object.\ncheck_convergence: A function to check whether convergence has been reached. Receives a GrapeResult object result, and should set result.converged to true and result.message to an appropriate string in case of convergence. Multiple convergence checks can be performed by chaining functions with ∘. The convergence check is performed after any calls to update_hook and info_hook.\nx_tol: Parameter for Optim.jl\nf_tol: Parameter for Optim.jl\ng_tol: Parameter for Optim.jl\nshow_trace: Parameter for Optim.jl\nextended_trace:  Parameter for Optim.jl\nshow_every: Parameter for Optim.jl\nallow_f_increases: Parameter for Optim.jl\noptimizer: An optional Optim.jl optimizer (Optim.AbstractOptimizer instance). If not given, an L-BFGS-B optimizer will be used.\nprop_method/fw_prop_method/bw_prop_method: The propagation method to use for each objective, see below.\nprop_method/fw_prop_method/grad_prop_method: The propagation method to use for the extended gradient vector for each objective, see below.\nverbose=false: If true, print information during initialization\n\nThe propagation method for the forward propagation of each objective is determined by the first available item of the following:\n\na fw_prop_method keyword argument\na prop_method keyword argument\na property fw_prop_method of the objective\na property prop_method of the objective\nthe value :auto\n\nThe propagation method for the backward propagation is determined similarly, but with bw_prop_method instead of fw_prop_method. The propagation method for the backward propagation of the extended gradient vector for each objective is determined from grad_prop_method, fw_prop_method, prop_method in order of precedence.\n\n\n\n\n\n","category":"method"},{"location":"api/#GRAPE.print_table-Tuple{Any, Any, Vararg{Any}}","page":"API","title":"GRAPE.print_table","text":"Print optimization progress as a table.\n\nThis functions serves as the default info_hook for an optimization with GRAPE.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumControlBase.optimize-Tuple{Any, Val{:GRAPE}}","page":"API","title":"QuantumControlBase.optimize","text":"opt_result = optimize(problem; method=:GRAPE, kwargs...)\n\noptimizes problem using GRadident Ascent Pulse Engineering (GRAPE), see GRAPE.optimize_grape.\n\n\n\n\n\n","category":"method"},{"location":"overview/#Overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"examples/perfect_entanglers/","page":"Example 2 (PE)","title":"Example 2 (PE)","text":"EditURL = \"https://github.com/JuliaQuantumControl/GRAPE.jl/blob/master/examples/perfect_entanglers.jl\"","category":"page"},{"location":"examples/perfect_entanglers/#Example-2:-Entangling-quantum-gates-for-coupled-transmon-qubits","page":"Example 2 (PE)","title":"Example 2: Entangling quantum gates for coupled transmon qubits","text":"","category":"section"},{"location":"examples/perfect_entanglers/","page":"Example 2 (PE)","title":"Example 2 (PE)","text":"tip: Tip\nThis example is also available as a Jupyter notebook: perfect_entanglers.ipynb.Compare this example against the related example using Krotov's method.","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 2 (PE)","title":"Example 2 (PE)","text":"gdefOp1hat1 gdefop1hat1 gdefinittextinit gdeftgttexttgt gdefReoperatornameRe gdefImoperatornameIm","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 2 (PE)","title":"Example 2 (PE)","text":"using DrWatson\n@quickactivate \"GRAPETests\"\nusing QuantumControl","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 2 (PE)","title":"Example 2 (PE)","text":"This example illustrates the optimization towards a perfectly entangling two-qubit gate for a system of two transmon qubits with a shared transmission line. It goes through three progressively more advanced optimizations:","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 2 (PE)","title":"Example 2 (PE)","text":"The direct optimization for a OpO = sqrttextiSWAP gate with a standard square-modulus functional\nThe optimization towards a perfect entangler using the functional developed in Goerz et al., Phys. Rev. A 91, 062307 (2015)\nThe direct maximization of of the gate concurrence","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 2 (PE)","title":"Example 2 (PE)","text":"While the first example evaluates the gradient of the optimization functional analytically, the latter two are examples for the use of automatic differentiation, or more specifically semi-automatic differentiation, as developed in Goerz et al., arXiv:2205.15044. The optimization of the gate concurrence specifically illustrates the optimization of a functional that is inherently non-analytical.","category":"page"},{"location":"examples/perfect_entanglers/#Hamiltonian-and-guess-pulses","page":"Example 2 (PE)","title":"Hamiltonian and guess pulses","text":"","category":"section"},{"location":"examples/perfect_entanglers/","page":"Example 2 (PE)","title":"Example 2 (PE)","text":"We will write the Hamiltonian in units of GHz (angular frequency; the factor 2π is implicit) and ns:","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 2 (PE)","title":"Example 2 (PE)","text":"const GHz = 2π\nconst MHz = 0.001GHz\nconst ns = 1.0\nconst μs = 1000ns;\nnothing #hide","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 2 (PE)","title":"Example 2 (PE)","text":"The Hamiltonian and parameter are taken from Goerz et. al., Phys. Rev. A 91, 062307 (2015)., cf. Table 1 in that Reference.","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 2 (PE)","title":"Example 2 (PE)","text":"⊗ = kron\nconst 𝕚 = 1im\nconst N = 6  # levels per transmon\n\nusing LinearAlgebra\nusing SparseArrays\n\nfunction transmon_hamiltonian(;\n    Ωre,\n    Ωim,\n    N=N,  # levels per transmon\n    ω₁=4.380GHz,\n    ω₂=4.614GHz,\n    ωd=4.498GHz,\n    α₁=-210MHz,\n    α₂=-215MHz,\n    J=-3MHz,\n    λ=1.03,\n    use_sparse=:auto\n)\n    𝟙 = SparseMatrixCSC{ComplexF64,Int64}(sparse(I, N, N))\n    b̂₁ = spdiagm(1 => complex.(sqrt.(collect(1:N-1)))) ⊗ 𝟙\n    b̂₂ = 𝟙 ⊗ spdiagm(1 => complex.(sqrt.(collect(1:N-1))))\n    b̂₁⁺ = sparse(b̂₁')\n    b̂₂⁺ = sparse(b̂₂')\n    n̂₁ = sparse(b̂₁' * b̂₁)\n    n̂₂ = sparse(b̂₂' * b̂₂)\n    n̂₁² = sparse(n̂₁ * n̂₁)\n    n̂₂² = sparse(n̂₂ * n̂₂)\n    b̂₁⁺_b̂₂ = sparse(b̂₁' * b̂₂)\n    b̂₁_b̂₂⁺ = sparse(b̂₁ * b̂₂')\n\n    ω̃₁ = ω₁ - ωd\n    ω̃₂ = ω₂ - ωd\n\n    Ĥ₀ = sparse(\n        (ω̃₁ - α₁ / 2) * n̂₁ +\n        (α₁ / 2) * n̂₁² +\n        (ω̃₂ - α₂ / 2) * n̂₂ +\n        (α₂ / 2) * n̂₂² +\n        J * (b̂₁⁺_b̂₂ + b̂₁_b̂₂⁺)\n    )\n\n    Ĥ₁re = (1 / 2) * (b̂₁ + b̂₁⁺ + λ * b̂₂ + λ * b̂₂⁺)\n    Ĥ₁im = (𝕚 / 2) * (b̂₁⁺ - b̂₁ + λ * b̂₂⁺ - λ * b̂₂)\n\n    if ((N < 5) && (use_sparse ≢ true)) || use_sparse ≡ false\n        H = hamiltonian(Array(Ĥ₀), (Array(Ĥ₁re), Ωre), (Array(Ĥ₁im), Ωim))\n    else\n        H = hamiltonian(Ĥ₀, (Ĥ₁re, Ωre), (Ĥ₁im, Ωim))\n    end\n    return H\n\nend;\nnothing #hide","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 2 (PE)","title":"Example 2 (PE)","text":"We choose a pulse duration of 400 ns. The guess pulse amplitude is 35 MHz, with a 15 ns switch-on/-off time. This switch-on/-off must be maintained in the optimization: A pulse that does not start from or end at zero would not be physical. For GRAPE, we can achieve this by using a ShapedAmplitude:","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 2 (PE)","title":"Example 2 (PE)","text":"using QuantumControl.Amplitudes: ShapedAmplitude","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 2 (PE)","title":"Example 2 (PE)","text":"This allows to have a control amplitude Ω(t) = S(t) ϵ(t) where S(t) is a fixed shape and ϵ(t) is the pulse directly tuned by the optimization. We start with a constant ϵ(t) and do not place any restrictions on how the optimization might update ϵ(t).","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 2 (PE)","title":"Example 2 (PE)","text":"The Hamiltonian is written in a rotating frame, so in general, the control field is allowed to be complex-valued. We separate this into two control fields, one for the real part and one for the imaginary part. Initially, the imaginary part is zero, corresponding to a field exactly at the frequency of the rotating frame.","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 2 (PE)","title":"Example 2 (PE)","text":"Note that passing tlist to ShapedAmplitude discretizes both the control and the shape function to the midpoints of the tlist array.","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 2 (PE)","title":"Example 2 (PE)","text":"using QuantumControl.Shapes: flattop\n\nfunction guess_amplitudes(; T=400ns, E₀=35MHz, dt=0.1ns, t_rise=15ns)\n\n    tlist = collect(range(0, T, step=dt))\n    shape(t) = flattop(t, T=T, t_rise=t_rise)\n    Ωre = ShapedAmplitude(t -> E₀, tlist; shape)\n    Ωim = ShapedAmplitude(t -> 0.0, tlist; shape)\n\n    return tlist, Ωre, Ωim\n\nend\n\ntlist, Ωre_guess, Ωim_guess = guess_amplitudes();\nnothing #hide","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 2 (PE)","title":"Example 2 (PE)","text":"We can visualize this:","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 2 (PE)","title":"Example 2 (PE)","text":"using Plots\nPlots.default(\n    linewidth               = 3,\n    size                    = (550, 300),\n    legend                  = :right,\n    foreground_color_legend = nothing,\n    background_color_legend = RGBA(1, 1, 1, 0.8),\n)\nusing QuantumControl.Controls: discretize\n\nfunction plot_complex_pulse(tlist, Ω; time_unit=:ns, ampl_unit=:MHz, kwargs...)\n\n    Ω = discretize(Ω, tlist)  # make sure Ω is defined on *points* of `tlist`\n\n    ax1 = plot(\n        tlist ./ eval(time_unit),\n        abs.(Ω) ./ eval(ampl_unit);\n        label=\"|Ω|\",\n        xlabel=\"time ($time_unit)\",\n        ylabel=\"amplitude ($ampl_unit)\",\n        kwargs...\n    )\n\n    ax2 = plot(\n        tlist ./ eval(time_unit),\n        angle.(Ω) ./ π;\n        label=\"ϕ(Ω)\",\n        xlabel=\"time ($time_unit)\",\n        ylabel=\"phase (π)\"\n    )\n\n    plot(ax1, ax2, layout=(2, 1))\n\nend\n\nplot_complex_pulse(tlist, Array(Ωre_guess) .+ 𝕚 .* Array(Ωim_guess))","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 2 (PE)","title":"Example 2 (PE)","text":"We now instantiate the Hamiltonian with these control fields:","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 2 (PE)","title":"Example 2 (PE)","text":"H = transmon_hamiltonian(Ωre=Ωre_guess, Ωim=Ωim_guess)","category":"page"},{"location":"examples/perfect_entanglers/#Logical-basis-for-two-qubit-gates","page":"Example 2 (PE)","title":"Logical basis for two-qubit gates","text":"","category":"section"},{"location":"examples/perfect_entanglers/","page":"Example 2 (PE)","title":"Example 2 (PE)","text":"For simplicity, we will be define the qubits in the bare basis, i.e. ignoring the static coupling J.","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 2 (PE)","title":"Example 2 (PE)","text":"function ket(i::Int64; N=N)\n    Ψ = zeros(ComplexF64, N)\n    Ψ[i+1] = 1\n    return Ψ\nend\n\nfunction ket(indices::Int64...; N=N)\n    Ψ = ket(indices[1]; N=N)\n    for i in indices[2:end]\n        Ψ = Ψ ⊗ ket(i; N=N)\n    end\n    return Ψ\nend\n\nfunction ket(label::AbstractString; N=N)\n    indices = [parse(Int64, digit) for digit in label]\n    return ket(indices...; N=N)\nend;\nnothing #hide","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 2 (PE)","title":"Example 2 (PE)","text":"basis = [ket(\"00\"), ket(\"01\"), ket(\"10\"), ket(\"11\")];\nnothing #hide","category":"page"},{"location":"examples/perfect_entanglers/#Optimizing-for-a-specific-quantum-gate","page":"Example 2 (PE)","title":"Optimizing for a specific quantum gate","text":"","category":"section"},{"location":"examples/perfect_entanglers/","page":"Example 2 (PE)","title":"Example 2 (PE)","text":"Our target gate is OpO = sqrttextiSWAP:","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 2 (PE)","title":"Example 2 (PE)","text":"SQRTISWAP = [\n    1  0    0   0\n    0 1/√2 𝕚/√2 0\n    0 𝕚/√2 1/√2 0\n    0  0    0   1\n];\nnothing #hide","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 2 (PE)","title":"Example 2 (PE)","text":"For each basis state, we get a target state that results from applying the gate to the basis state (you can convince yourself that this equivalent multiplying the transpose of the above gate matrix to the vector of basis states):","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 2 (PE)","title":"Example 2 (PE)","text":"basis_tgt = transpose(SQRTISWAP) * basis;\nnothing #hide","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 2 (PE)","title":"Example 2 (PE)","text":"The mapping from each initial (basis) state to the corresponding target state constitutes an \"objective\" for the optimization:","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 2 (PE)","title":"Example 2 (PE)","text":"objectives = [\n    Objective(initial_state=Ψ, target_state=Ψtgt, generator=H) for\n    (Ψ, Ψtgt) ∈ zip(basis, basis_tgt)\n];\nnothing #hide","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 2 (PE)","title":"Example 2 (PE)","text":"We can analyze how all of the basis states evolve under the guess controls in one go:","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 2 (PE)","title":"Example 2 (PE)","text":"guess_states = propagate_objectives(objectives, tlist; use_threads=true);\nnothing #hide","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 2 (PE)","title":"Example 2 (PE)","text":"The gate implemented by the guess controls is","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 2 (PE)","title":"Example 2 (PE)","text":"U_guess = [basis[i] ⋅ guess_states[j] for i = 1:4, j = 1:4];\nnothing #hide","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 2 (PE)","title":"Example 2 (PE)","text":"We will optimize these objectives with a square-modulus functional","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 2 (PE)","title":"Example 2 (PE)","text":"using QuantumControl.Functionals: J_T_sm","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 2 (PE)","title":"Example 2 (PE)","text":"The initial value of the functional is","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 2 (PE)","title":"Example 2 (PE)","text":"J_T_sm(guess_states, objectives)","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 2 (PE)","title":"Example 2 (PE)","text":"which is the gate error","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 2 (PE)","title":"Example 2 (PE)","text":"1 - (abs(tr(U_guess' * SQRTISWAP)) / 4)^2","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 2 (PE)","title":"Example 2 (PE)","text":"Now, we define the full optimization problems on top of the list of objectives, and with the optimization functional:","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 2 (PE)","title":"Example 2 (PE)","text":"problem = ControlProblem(\n    objectives=objectives,\n    tlist=tlist,\n    iter_stop=100,\n    J_T=J_T_sm,\n    check_convergence=res -> begin\n        (\n            (res.J_T > res.J_T_prev) &&\n            (res.converged = true) &&\n            (res.message = \"Loss of monotonic convergence\")\n        )\n        ((res.J_T <= 1e-3) && (res.converged = true) && (res.message = \"J_T < 10⁻³\"))\n    end,\n    use_threads=true,\n);\nnothing #hide","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 2 (PE)","title":"Example 2 (PE)","text":"opt_result = @optimize_or_load(datadir(\"GATE_OCT.jld2\"), problem; method=:GRAPE, force=true);\nnothing #hide","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 2 (PE)","title":"Example 2 (PE)","text":"opt_result","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 2 (PE)","title":"Example 2 (PE)","text":"We extract the optimized control field from the optimization result and plot the resulting amplitude.","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 2 (PE)","title":"Example 2 (PE)","text":"The optimized_controls field of the opt_results contains the optimized controls ϵ(t).","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 2 (PE)","title":"Example 2 (PE)","text":"ϵ_opt = opt_result.optimized_controls[1] + 𝕚 * opt_result.optimized_controls[2];\nnothing #hide","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 2 (PE)","title":"Example 2 (PE)","text":"These must still be multiplied by the static shape S(t) that we set up for the guess amplitudes","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 2 (PE)","title":"Example 2 (PE)","text":"Ω_opt = ϵ_opt .* discretize(Ωre_guess.shape, tlist)\n\nplot_complex_pulse(tlist, Ω_opt)","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 2 (PE)","title":"Example 2 (PE)","text":"We then propagate the optimized control field to analyze the resulting quantum gate:","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 2 (PE)","title":"Example 2 (PE)","text":"using QuantumControl.Controls: get_controls, substitute\n\nopt_states = propagate_objectives(\n    substitute(\n        objectives,\n        IdDict(zip(get_controls(objectives), opt_result.optimized_controls))\n    ),\n    tlist;\n    use_threads=true\n);\nnothing #hide","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 2 (PE)","title":"Example 2 (PE)","text":"The resulting gate is","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 2 (PE)","title":"Example 2 (PE)","text":"U_opt = [basis[i] ⋅ opt_states[j] for i = 1:4, j = 1:4];\nnothing #hide","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 2 (PE)","title":"Example 2 (PE)","text":"and we can verify the resulting fidelity","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 2 (PE)","title":"Example 2 (PE)","text":"(abs(tr(U_opt' * SQRTISWAP)) / 4)^2","category":"page"},{"location":"examples/perfect_entanglers/#Optimizing-for-a-general-perfect-entangler","page":"Example 2 (PE)","title":"Optimizing for a general perfect entangler","text":"","category":"section"},{"location":"examples/perfect_entanglers/","page":"Example 2 (PE)","title":"Example 2 (PE)","text":"We define the optimization with one objective for each of the four basis states:","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 2 (PE)","title":"Example 2 (PE)","text":"objectives = [Objective(; initial_state=Ψ, generator=H) for Ψ ∈ basis];\nnothing #hide","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 2 (PE)","title":"Example 2 (PE)","text":"Note that we omit the target_state here. This is because we will be optimizing for an arbitrary perfect entangler, not for a specific quantum gate. Thus, there is no a-priori known target state to which the initial state must evolve.","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 2 (PE)","title":"Example 2 (PE)","text":"The optimization is steered by the perfect entanglers distance measure D_PE, that is, the geometric distance of the quantum gate obtained from propagating the four basis states to the polyhedron of perfect entanglers in the Weyl chamber. Since the logical subspace defining the qubit is embedded in the larger Hilbert space of the transmon, there may be loss of population from the logical subspace. To counter this possibility in the optimization, we add a unitarity measure  to D_PE. The two terms are added with equal weight.","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 2 (PE)","title":"Example 2 (PE)","text":"using QuantumControl.WeylChamber: D_PE, gate_concurrence, unitarity\nusing QuantumControl.Functionals: gate_functional\n\nJ_T_PE = gate_functional(D_PE; unitarity_weight=0.5);\nnothing #hide","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 2 (PE)","title":"Example 2 (PE)","text":"The gate_functional routines used above converts the function D_PE that receives the gate U as a 4×4 matrix into a functional of the correct from for the QuantumControl.optimize routine, which is a function of the propagated states.","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 2 (PE)","title":"Example 2 (PE)","text":"We can check that for the guess pulse, we are not implementing a perfect entangler","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 2 (PE)","title":"Example 2 (PE)","text":"gate_concurrence(U_guess)","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 2 (PE)","title":"Example 2 (PE)","text":"We find that the guess pulse produces a gate in the W0* region of the Weyl chamber:","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 2 (PE)","title":"Example 2 (PE)","text":"using QuantumControl.WeylChamber: weyl_chamber_region\nweyl_chamber_region(U_guess)","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 2 (PE)","title":"Example 2 (PE)","text":"That is, the region of the Weyl chamber containing controlled-phase gates with a phase  π (Weyl chamber coordinates c₁  π2, c₂  π4).","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 2 (PE)","title":"Example 2 (PE)","text":"This in fact allows use to use the perfect entangler functional without modification: if the guess pulse were in the \"W1\" region of the Weyl chamber, (close to SWAP), we would have to flip its sign, or we would optimize towards the local equivalence class of the SWAP gate instead of towards the perfect of perfect entanglers. In principle, we could use a modified functional that takes the absolute square of the D_PE term, by using","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 2 (PE)","title":"Example 2 (PE)","text":"J_T_PE = gate_functional(D_PE; unitarity_weight=0.5, absolute_square=true)","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 2 (PE)","title":"Example 2 (PE)","text":"This would specifically optimize for the surface of the perfect entanglers functional.","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 2 (PE)","title":"Example 2 (PE)","text":"The guess pulse loses about 10% of population from the logical subspace:","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 2 (PE)","title":"Example 2 (PE)","text":"1 - unitarity(U_guess)","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 2 (PE)","title":"Example 2 (PE)","text":"We can also evaluate the geometric distance to the polyhedron of perfect entanglers in the Weyl chamber:","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 2 (PE)","title":"Example 2 (PE)","text":"D_PE(U_guess)","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 2 (PE)","title":"Example 2 (PE)","text":"Together with the unitarity measure, this is the initial value of the optimization functional:","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 2 (PE)","title":"Example 2 (PE)","text":"0.5 * D_PE(U_guess) + 0.5 * (1 - unitarity(U_guess))","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 2 (PE)","title":"Example 2 (PE)","text":"J_T_PE(guess_states, objectives)","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 2 (PE)","title":"Example 2 (PE)","text":"For the standard functional J_T_sm used in the previous section, our GRAPE was able to automatically use an analytic implementation of the gradient. For the perfect-entanglers functional, an analytic gradient exist, but is very cumbersome to implement. Instead, we make use of semi-automatic differentiation. As shown in Goerz et al., arXiv:2205.15044, by evaluating the gradient via a chain rule in the propagated states, the dependency of the gradient on the final time functional is pushed into the boundary condition for the backward propagation, χ_k = -J_Tϕ_k. We can further exploit that J_T is an explicit function of the two-qubit gate in the computational basis and use a chain rule with respect to the elements of the two-qubit gate U_kk. The remaining derivatives J_TU_kk are then obtained via automatic differentiation. This is set up via the make_gate_chi function,","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 2 (PE)","title":"Example 2 (PE)","text":"using QuantumControl.Functionals: make_gate_chi\nchi_pe = make_gate_chi(D_PE, objectives; unitarity_weight=0.5);\nnothing #hide","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 2 (PE)","title":"Example 2 (PE)","text":"where the resulting chi_pe must be passed to the optimization.","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 2 (PE)","title":"Example 2 (PE)","text":"Now, we formulate the full control problem","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 2 (PE)","title":"Example 2 (PE)","text":"problem = ControlProblem(\n    objectives=objectives,\n    tlist=tlist,\n    iter_stop=100,\n    J_T=J_T_PE,\n    chi=chi_pe,\n    check_convergence=res -> begin\n        (\n            (res.J_T > res.J_T_prev) &&\n            (res.converged = true) &&\n            (res.message = \"Loss of monotonic convergence\")\n        )\n        (\n            (res.J_T <= 1e-3) &&\n            (res.converged = true) &&\n            (res.message = \"Found a perfect entangler\")\n        )\n    end,\n    use_threads=true,\n);\nnothing #hide","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 2 (PE)","title":"Example 2 (PE)","text":"With this, we can easily find a solution to the control problem:","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 2 (PE)","title":"Example 2 (PE)","text":"opt_result = @optimize_or_load(datadir(\"PE_OCT.jld2\"), problem; method=:GRAPE, force=true);\nnothing #hide","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 2 (PE)","title":"Example 2 (PE)","text":"opt_result","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 2 (PE)","title":"Example 2 (PE)","text":"We extract the optimized control field from the optimization result and plot it","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 2 (PE)","title":"Example 2 (PE)","text":"ϵ_opt = opt_result.optimized_controls[1] + 𝕚 * opt_result.optimized_controls[2]\nΩ_opt = ϵ_opt .* discretize(Ωre_guess.shape, tlist)\n\nplot_complex_pulse(tlist, Ω_opt)","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 2 (PE)","title":"Example 2 (PE)","text":"We then propagate the optimized control field to analyze the resulting quantum gate:","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 2 (PE)","title":"Example 2 (PE)","text":"opt_states = propagate_objectives(\n    substitute(\n        objectives,\n        IdDict(zip(get_controls(objectives), opt_result.optimized_controls))\n    ),\n    tlist;\n    use_threads=true\n);\n\nU_opt = [basis[i] ⋅ opt_states[j] for i = 1:4, j = 1:4];\nnothing #hide","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 2 (PE)","title":"Example 2 (PE)","text":"We find that we have achieved a perfect entangler:","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 2 (PE)","title":"Example 2 (PE)","text":"gate_concurrence(U_opt)","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 2 (PE)","title":"Example 2 (PE)","text":"Moreover, we have reduced the population loss to less than 4%","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 2 (PE)","title":"Example 2 (PE)","text":"1 - unitarity(U_opt)","category":"page"},{"location":"examples/perfect_entanglers/#Direct-maximization-of-the-gate-concurrence","page":"Example 2 (PE)","title":"Direct maximization of the gate concurrence","text":"","category":"section"},{"location":"examples/perfect_entanglers/","page":"Example 2 (PE)","title":"Example 2 (PE)","text":"In the previous optimizations, we have optimized for a perfect entangler indirectly via a geometric function in the Weyl chamber. The entire reason that perfect entangler functional was formulated is because calculating the gate concurrence directly involves the eigenvalues of the unitary, see Kraus, Cirac, Phys. Rev. A 63, 062309 (2001) and Childs et al., PRA 68, 052311 (2003), which are inherently non-analytic.","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 2 (PE)","title":"Example 2 (PE)","text":"However, since we are able to obtain gradient from automatic differentiation, this is no longer an insurmountable obstacle","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 2 (PE)","title":"Example 2 (PE)","text":"We can define a functional for a given gate U that combines the gate concurrence and (as above) a unitarity measure to penalize loss of population from the logical subspace:","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 2 (PE)","title":"Example 2 (PE)","text":"J_T_C = U -> 0.5 * (1 - gate_concurrence(U)) + 0.5 * (1 - unitarity(U));\nnothing #hide","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 2 (PE)","title":"Example 2 (PE)","text":"In the optimization, we will convert this functional to one that takes the propagated states as arguments (via the gate_functional routine). Also, as before, we have to create a matching routine for the boundary condition χ_k = -fracϕ_k J_T of the backward-propagation via the make_gate_chi routine.","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 2 (PE)","title":"Example 2 (PE)","text":"Running the optimization, we again are able to find a perfect entangler.","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 2 (PE)","title":"Example 2 (PE)","text":"opt_result_direct = @optimize_or_load(\n    datadir(\"PE_OCT_direct.jld2\"),\n    problem;\n    method=:GRAPE,\n    J_T=gate_functional(J_T_C),\n    chi=make_gate_chi(J_T_C, objectives),\n    force=true\n);\nnothing #hide","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 2 (PE)","title":"Example 2 (PE)","text":"opt_result_direct","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 2 (PE)","title":"Example 2 (PE)","text":"opt_states_direct = propagate_objectives(\n    substitute(\n        objectives,\n        IdDict(zip(get_controls(objectives), opt_result_direct.optimized_controls))\n    ),\n    tlist;\n    use_threads=true\n);\n\nU_opt_direct = [basis[i] ⋅ opt_states_direct[j] for i = 1:4, j = 1:4];\nnothing #hide","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 2 (PE)","title":"Example 2 (PE)","text":"gate_concurrence(U_opt_direct)","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 2 (PE)","title":"Example 2 (PE)","text":"1 - unitarity(U_opt_direct)","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 2 (PE)","title":"Example 2 (PE)","text":"","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 2 (PE)","title":"Example 2 (PE)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/#Examples","page":"List of Examples","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"List of Examples","title":"List of Examples","text":"Pages = [\n    \"simple_state_to_state.md\",\n    \"perfect_entanglers.md\",\n]\nDepth = 1","category":"page"},{"location":"examples/","page":"List of Examples","title":"List of Examples","text":"See also the general examples of the QuantumControl package.","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"EditURL = \"https://github.com/JuliaQuantumControl/GRAPE.jl/blob/master/examples/simple_state_to_state.jl\"","category":"page"},{"location":"examples/simple_state_to_state/#Example-1:-Optimization-of-a-State-to-State-Transfer-in-a-Two-Level-System","page":"Example 1 (TLS)","title":"Example 1: Optimization of a State-to-State Transfer in a Two-Level-System","text":"","category":"section"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"tip: Tip\nThis example is also available as a Jupyter notebook: simple_state_to_state.ipynb.Compare this example against the same example using Krotov's method.","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"gdefop1hat1 gdefinittextinit gdeftgttexttgt","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"This first example illustrates the basic use of the GRAPE.jl by solving a simple canonical optimization problem: the transfer of population in a two level system.","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"using DrWatson\n@quickactivate \"GRAPETests\"","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"using QuantumControl","category":"page"},{"location":"examples/simple_state_to_state/#Two-level-Hamiltonian","page":"Example 1 (TLS)","title":"Two-level Hamiltonian","text":"","category":"section"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"We consider the Hamiltonian opH_0 = - fracomega2 opsigma_z, representing a simple qubit with energy level splitting omega in the basis ket0ket1. The control field epsilon(t) is assumed to couple via the Hamiltonian opH_1(t) = epsilon(t) opsigma_x to the qubit, i.e., the control field effectively drives transitions between both qubit states.","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"We we will use","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"ϵ(t) = 0.2 * QuantumControl.Shapes.flattop(t, T=5, t_rise=0.3, func=:blackman);\nnothing #hide","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"\"\"\"Two-level-system Hamiltonian.\"\"\"\nfunction tls_hamiltonian(Ω=1.0, ϵ=ϵ)\n    σ̂_z = ComplexF64[\n        1  0\n        0 -1\n    ]\n    σ̂_x = ComplexF64[\n        0  1\n        1  0\n    ]\n    Ĥ₀ = -0.5 * Ω * σ̂_z\n    Ĥ₁ = σ̂_x\n    return hamiltonian(Ĥ₀, (Ĥ₁, ϵ))\nend;\nnothing #hide","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"H = tls_hamiltonian();\nnothing #hide","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"The control field here switches on from zero at t=0 to it's maximum amplitude 0.2 within the time period 0.3 (the switch-on shape is half a Blackman pulse). It switches off again in the time period 0.3 before the final time T=5). We use a time grid with 500 time steps between 0 and T:","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"tlist = collect(range(0, 5, length=500));\nnothing #hide","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"using Plots\nPlots.default(\n    linewidth               = 3,\n    size                    = (550, 300),\n    legend                  = :right,\n    foreground_color_legend = nothing,\n    background_color_legend = RGBA(1, 1, 1, 0.8)\n)","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"function plot_control(pulse::Vector, tlist)\n    plot(tlist, pulse, xlabel=\"time\", ylabel=\"amplitude\", legend=false)\nend\n\nplot_control(ϵ::T, tlist) where {T<:Function} = plot_control([ϵ(t) for t in tlist], tlist);\nnothing #hide","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"fig = plot_control(ϵ, tlist)","category":"page"},{"location":"examples/simple_state_to_state/#Optimization-target","page":"Example 1 (TLS)","title":"Optimization target","text":"","category":"section"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"First, we define a convenience function for the eigenstates.","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"function ket(label)\n    result = Dict(\"0\" => Vector{ComplexF64}([1, 0]), \"1\" => Vector{ComplexF64}([0, 1]))\n    return result[string(label)]\nend;\nnothing #hide","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"The physical objective of our optimization is to transform the initial state ket0 into the target state ket1 under the time evolution induced by the Hamiltonian opH(t).","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"objectives = [Objective(initial_state=ket(0), generator=H, target_state=ket(1))];\nnothing #hide","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"The full control problem includes this objective, information about the time grid for the dynamics, and the functional to be used (the square modulus of the overlap tau with the target state in this case).","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"using QuantumControl.Functionals: J_T_sm\n\nproblem = ControlProblem(\n    objectives=objectives,\n    tlist=tlist,\n    pulse_options=Dict(),\n    iter_stop=500,\n    J_T=J_T_sm,\n    check_convergence=res -> begin\n        ((res.J_T < 1e-3) && (res.converged = true) && (res.message = \"J_T < 10⁻³\"))\n    end,\n);\nnothing #hide","category":"page"},{"location":"examples/simple_state_to_state/#Simulate-dynamics-under-the-guess-field","page":"Example 1 (TLS)","title":"Simulate dynamics under the guess field","text":"","category":"section"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"Before running the optimization procedure, we first simulate the dynamics under the guess field epsilon_0(t). The following solves equation of motion for the defined objective, which contains the initial state ketPsi_init and the Hamiltonian opH(t) defining its evolution.","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"guess_dynamics = propagate_objective(\n    objectives[1],\n    problem.tlist;\n    storage=true,\n    observables=(Ψ -> abs.(Ψ) .^ 2,)\n)","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"function plot_population(pop0::Vector, pop1::Vector, tlist)\n    fig = plot(tlist, pop0, label=\"0\", xlabel=\"time\", ylabel=\"population\")\n    plot!(fig, tlist, pop1; label=\"1\")\nend;\nnothing #hide","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"fig = plot_population(guess_dynamics[1, :], guess_dynamics[2, :], tlist)","category":"page"},{"location":"examples/simple_state_to_state/#Optimization-with-LBFGSB","page":"Example 1 (TLS)","title":"Optimization with LBFGSB","text":"","category":"section"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"In the following we optimize the guess field epsilon_0(t) such that the intended state-to-state transfer ketPsi_init rightarrow ketPsi_tgt is solved.","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"The GRAPE package performs the optimization by calculating the gradient of J_T with respect to the values of the control field at each point in time. This gradient is then fed into a backend solver that calculates an appropriate update based on that gradient.","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"By default, this backend is LBFGSB.jl, a wrapper around the true and tested L-BFGS-B Fortran library. L-BFGS-B is a pseudo-Hessian method: it efficiently estimates the second-order Hessian from the gradient information. The search direction determined from that Hessian dramatically improves convergence compared to using the gradient directly as a search direction. The L-BFGS-B method performs its own linesearch to determine how far to go in the search direction.","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"It can be quite instructive to see how the improvement in the pseudo-Hessian search direction compares to the gradient, how the linesearch finds an appropriate step width. For this purpose, we have a GRAPELinesearchAnalysis package that automatically generates plots in every iteration of the optimization showing the linesearch behavior","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"using GRAPELinesearchAnalysis","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"We feed this into the optimization as part of the info_hook.","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"opt_result_LBFGSB = @optimize_or_load(\n    datadir(\"TLS\", \"opt_result_LBFGSB.jld2\"),\n    problem,\n    method = :grape,\n    force = true,\n    info_hook = chain_infohooks(\n        GRAPELinesearchAnalysis.plot_linesearch(datadir(\"TLS\", \"Linesearch\", \"LBFGSB\")),\n        QuantumControl.GRAPE.print_table,\n    )\n);\nnothing #hide","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"When going through this tutorial locally, the generated images for the linesearch can be found in docs/TLS/Linesearch/LBFGSB.","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"datadir(\"TLS\", \"Linesearch\", \"LBFGSB\")","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"opt_result_LBFGSB","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"We can plot the optimized field:","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"fig = plot_control(opt_result_LBFGSB.optimized_controls[1], tlist)","category":"page"},{"location":"examples/simple_state_to_state/#Optimization-via-semi-automatic-differentiation","page":"Example 1 (TLS)","title":"Optimization via semi-automatic differentiation","text":"","category":"section"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"Our GRAPE implementation includes the analytic gradient of the optimization functional J_T_sm. Thus, we only had to pass the functional itself to the optimization. More generally, for functionals where the analytic gradient is not known, semi-automatic differentiation can be used to determine it automatically. For illustration, we may re-run the optimization forgoing the known analytic gradient and instead using an automatically determined gradient.","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"As shown in Goerz et al., arXiv:2205.15044, by evaluating the gradient of J_T via a chain rule in the propagated states, the dependency of the gradient on the final time functional is pushed into the boundary condition for the backward propagation, χ_k = -J_Tϕ_k. For functionals that can be written in terms of the overlaps τ_k of the forward-propagated states and target states, such as the J_T_sm used here, a further chain rule leaves derivatives of J_T with respect to the overlaps τ_k, which are easily obtained via automatic differentiation. This happens automatically if we use make_chi with force_zygote=true and pass the resulting chi to the optimization:","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"using QuantumControl.Functionals: make_chi\n\nchi_sm = make_chi(J_T_sm, objectives; force_zygote=true)\n\nopt_result_LBFGSB_via_χ = optimize(problem; method=:grape, chi=chi_sm);\nnothing #hide","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"opt_result_LBFGSB_via_χ","category":"page"},{"location":"examples/simple_state_to_state/#Optimization-with-Optim.jl","page":"Example 1 (TLS)","title":"Optimization with Optim.jl","text":"","category":"section"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"As an alternative to the default L-BFGS-B backend, we can also use any of the gradient-based optimizers in Optiml.jl. This also gives full control over the linesearch method.","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"import Optim\nimport LineSearches","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"Here, we use the LBFGS implementation that is part of Optim (which is not exactly the same as L-BFGS-B; \"B\" being the variant of LBFGS with optional additional bounds on the control) with a Hager-Zhang linesearch","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"opt_result_OptimLBFGS = @optimize_or_load(\n    datadir(\"TLS\", \"opt_result_OptimLBFGS.jld2\"),\n    problem,\n    method = :grape,\n    force = true,\n    info_hook = chain_infohooks(\n        GRAPELinesearchAnalysis.plot_linesearch(datadir(\"TLS\", \"Linesearch\", \"OptimLBFGS\")),\n        QuantumControl.GRAPE.print_table,\n    ),\n    optimizer = Optim.LBFGS(;\n        alphaguess=LineSearches.InitialStatic(alpha=0.2),\n        linesearch=LineSearches.HagerZhang(alphamax=2.0)\n    )\n);\nnothing #hide","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"opt_result_OptimLBFGS","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"We can plot the optimized field:","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"fig = plot_control(opt_result_OptimLBFGS.optimized_controls[1], tlist)","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"We can see that the choice of linesearch parameters in particular strongly influence the convergence and the resulting field. Play around with different methods and parameters, and compare the different plots generated by GRAPELinesearchAnalysis!","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"Empirically, we find the default L-BFGS-B to have a very well-behaved linesearch.","category":"page"},{"location":"examples/simple_state_to_state/#Simulate-the-dynamics-under-the-optimized-field","page":"Example 1 (TLS)","title":"Simulate the dynamics under the optimized field","text":"","category":"section"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"Having obtained the optimized control field, we can simulate the dynamics to verify that the optimized field indeed drives the initial state ketPsi_init = ket0 to the desired target state ketPsi_tgt = ket1.","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"using QuantumControl.Controls: substitute\n\nopt_dynamics = propagate_objective(\n    substitute(objectives[1], IdDict(ϵ => opt_result_LBFGSB.optimized_controls[1])),\n    problem.tlist;\n    storage=true,\n    observables=(Ψ -> abs.(Ψ) .^ 2,)\n)","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"fig = plot_population(opt_dynamics[1, :], opt_dynamics[2, :], tlist)","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = GRAPE","category":"page"},{"location":"#GRAPE.jl","page":"Home","title":"GRAPE.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Implementation of (second-order) GRadient Ascent Pulse Engineering (GRAPE) extended with automatic differentiation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Part of QuantumControl.jl and the JuliaQuantumControl organization.","category":"page"},{"location":"#Contents","page":"Home","title":"Contents","text":"","category":"section"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"overview.md\",\n]\nDepth = 1","category":"page"},{"location":"#Examples","page":"Home","title":"Examples","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"examples/simple_state_to_state.md\",\n    \"examples/perfect_entanglers.md\",\n]\nDepth = 1","category":"page"},{"location":"","page":"Home","title":"Home","text":"See also the general examples of the QuantumControl package.","category":"page"},{"location":"#API","page":"Home","title":"API","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"api.md\",\n]\nDepth = 1","category":"page"},{"location":"#History","page":"Home","title":"History","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"See the Releases on Github.","category":"page"}]
}
