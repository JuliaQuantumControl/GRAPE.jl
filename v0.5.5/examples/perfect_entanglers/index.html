<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Example 2 (PE) · GRAPE.jl</title><meta name="title" content="Example 2 (PE) · GRAPE.jl"/><meta property="og:title" content="Example 2 (PE) · GRAPE.jl"/><meta property="twitter:title" content="Example 2 (PE) · GRAPE.jl"/><meta name="description" content="Documentation for GRAPE.jl."/><meta property="og:description" content="Documentation for GRAPE.jl."/><meta property="twitter:description" content="Documentation for GRAPE.jl."/><meta property="og:url" content="https://juliaquantumcontrol.github.io/GRAPE.jl/examples/perfect_entanglers/"/><meta property="twitter:url" content="https://juliaquantumcontrol.github.io/GRAPE.jl/examples/perfect_entanglers/"/><link rel="canonical" href="https://juliaquantumcontrol.github.io/GRAPE.jl/examples/perfect_entanglers/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">GRAPE.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../overview/">Overview</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../">List of Examples</a></li><li><a class="tocitem" href="../simple_state_to_state/">Example 1 (TLS)</a></li><li class="is-active"><a class="tocitem" href>Example 2 (PE)</a><ul class="internal"><li><a class="tocitem" href="#Hamiltonian-and-guess-pulses"><span>Hamiltonian and guess pulses</span></a></li><li><a class="tocitem" href="#Logical-basis-for-two-qubit-gates"><span>Logical basis for two-qubit gates</span></a></li><li><a class="tocitem" href="#Optimizing-for-a-specific-quantum-gate"><span>Optimizing for a specific quantum gate</span></a></li><li><a class="tocitem" href="#Optimizing-for-a-general-perfect-entangler"><span>Optimizing for a general perfect entangler</span></a></li><li><a class="tocitem" href="#Direct-maximization-of-the-gate-concurrence"><span>Direct maximization of the gate concurrence</span></a></li></ul></li></ul></li><li><a class="tocitem" href="../../api/">API</a></li><li><a class="tocitem" href="../../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Example 2 (PE)</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Example 2 (PE)</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaQuantumControl/GRAPE.jl/blob/master/examples/perfect_entanglers.jl#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Example-2:-Entangling-quantum-gates-for-coupled-transmon-qubits"><a class="docs-heading-anchor" href="#Example-2:-Entangling-quantum-gates-for-coupled-transmon-qubits">Example 2: Entangling quantum gates for coupled transmon qubits</a><a id="Example-2:-Entangling-quantum-gates-for-coupled-transmon-qubits-1"></a><a class="docs-heading-anchor-permalink" href="#Example-2:-Entangling-quantum-gates-for-coupled-transmon-qubits" title="Permalink"></a></h1><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>This example is also available as a Jupyter notebook: <a href="https://nbviewer.jupyter.org/github/JuliaQuantumControl/GRAPE.jl/blob/gh-pages/v0.5.5/examples/perfect_entanglers.ipynb"><code>perfect_entanglers.ipynb</code></a>.</p><p>Compare this example against the <a href="https://juliaquantumcontrol.github.io/Krotov.jl/stable/examples/perfect_entanglers/">related example using Krotov&#39;s method</a>.</p></div></div><p><span>$\gdef\Op#1{\hat{#1}}$</span> <span>$\gdef\op#1{\hat{#1}}$</span> <span>$\gdef\init{\text{init}}$</span> <span>$\gdef\tgt{\text{tgt}}$</span> <span>$\gdef\Re{\operatorname{Re}}$</span> <span>$\gdef\Im{\operatorname{Im}}$</span></p><pre><code class="language-julia hljs">const PROJECTDIR = dirname(Base.active_project());
projectdir(names...) = joinpath(PROJECTDIR, names...);
datadir(names...) = projectdir(&quot;data&quot;, names...);</code></pre><p>This example illustrates the optimization towards a perfectly entangling two-qubit gate for a system of two transmon qubits with a shared transmission line. It goes through three progressively more advanced optimizations:</p><ol><li>The direct optimization for a <span>$\Op{O} = \sqrt{\text{iSWAP}}$</span> gate with a standard square-modulus functional</li><li>The optimization towards a perfect entangler using the functional developed in Goerz <em>et al.</em>, Phys. Rev. A 91, 062307 (2015) <a href="../../references/#GoerzPRA2015">[4]</a></li><li>The direct maximization of of the gate concurrence</li></ol><p>While the first example evaluates the gradient of the optimization functional analytically, the latter two are examples for the use of automatic differentiation, or more specifically semi-automatic differentiation, as developed in <a href="../../references/#GoerzQ2022">Goerz *et al.* [3]</a>. The optimization of the gate concurrence specifically illustrates the optimization of a functional that is inherently non-analytical.</p><h2 id="Hamiltonian-and-guess-pulses"><a class="docs-heading-anchor" href="#Hamiltonian-and-guess-pulses">Hamiltonian and guess pulses</a><a id="Hamiltonian-and-guess-pulses-1"></a><a class="docs-heading-anchor-permalink" href="#Hamiltonian-and-guess-pulses" title="Permalink"></a></h2><p>We will write the Hamiltonian in units of GHz (angular frequency; the factor 2π is implicit) and ns:</p><pre><code class="language-julia hljs">const GHz = 2π
const MHz = 0.001GHz
const ns = 1.0
const μs = 1000ns;</code></pre><p>The Hamiltonian and parameters are taken from Ref. <a href="../../references/#GoerzPRA2015">[4, Table 1]</a>.</p><pre><code class="language-julia hljs">⊗ = kron
const 𝕚 = 1im
const N = 6  # levels per transmon

using LinearAlgebra
using SparseArrays
using QuantumControl


function transmon_hamiltonian(;
    Ωre,
    Ωim,
    N=N,  # levels per transmon
    ω₁=4.380GHz,
    ω₂=4.614GHz,
    ωd=4.498GHz,
    α₁=-210MHz,
    α₂=-215MHz,
    J=-3MHz,
    λ=1.03,
    use_sparse=:auto
)
    𝟙 = SparseMatrixCSC{ComplexF64,Int64}(sparse(I, N, N))
    b̂₁ = spdiagm(1 =&gt; complex.(sqrt.(collect(1:N-1)))) ⊗ 𝟙
    b̂₂ = 𝟙 ⊗ spdiagm(1 =&gt; complex.(sqrt.(collect(1:N-1))))
    b̂₁⁺ = sparse(b̂₁&#39;)
    b̂₂⁺ = sparse(b̂₂&#39;)
    n̂₁ = sparse(b̂₁&#39; * b̂₁)
    n̂₂ = sparse(b̂₂&#39; * b̂₂)
    n̂₁² = sparse(n̂₁ * n̂₁)
    n̂₂² = sparse(n̂₂ * n̂₂)
    b̂₁⁺_b̂₂ = sparse(b̂₁&#39; * b̂₂)
    b̂₁_b̂₂⁺ = sparse(b̂₁ * b̂₂&#39;)

    ω̃₁ = ω₁ - ωd
    ω̃₂ = ω₂ - ωd

    Ĥ₀ = sparse(
        (ω̃₁ - α₁ / 2) * n̂₁ +
        (α₁ / 2) * n̂₁² +
        (ω̃₂ - α₂ / 2) * n̂₂ +
        (α₂ / 2) * n̂₂² +
        J * (b̂₁⁺_b̂₂ + b̂₁_b̂₂⁺)
    )

    Ĥ₁re = (1 / 2) * (b̂₁ + b̂₁⁺ + λ * b̂₂ + λ * b̂₂⁺)
    Ĥ₁im = (𝕚 / 2) * (b̂₁⁺ - b̂₁ + λ * b̂₂⁺ - λ * b̂₂)

    if ((N &lt; 5) &amp;&amp; (use_sparse ≢ true)) || use_sparse ≡ false
        H = hamiltonian(Array(Ĥ₀), (Array(Ĥ₁re), Ωre), (Array(Ĥ₁im), Ωim))
    else
        H = hamiltonian(Ĥ₀, (Ĥ₁re, Ωre), (Ĥ₁im, Ωim))
    end
    return H

end;</code></pre><p>We choose a pulse duration of 400 ns. The guess pulse amplitude is 35 MHz, with a 15 ns switch-on/-off time. This switch-on/-off must be maintained in the optimization: A pulse that does not start from or end at zero would not be physical. For GRAPE, we can achieve this by using a <code>ShapedAmplitude</code>:</p><pre><code class="language-julia hljs">using QuantumControl.Amplitudes: ShapedAmplitude</code></pre><p>This allows to have a control amplitude <span>$Ω(t) = S(t) ϵ(t)$</span> where <span>$S(t)$</span> is a fixed shape and <span>$ϵ(t)$</span> is the pulse directly tuned by the optimization. We start with a constant <span>$ϵ(t)$</span> and do not place any restrictions on how the optimization might update <span>$ϵ(t)$</span>.</p><p>The Hamiltonian is written in a rotating frame, so in general, the control field is allowed to be complex-valued. We separate this into two control fields, one for the real part and one for the imaginary part. Initially, the imaginary part is zero, corresponding to a field exactly at the frequency of the rotating frame.</p><p>Note that passing <code>tlist</code> to <code>ShapedAmplitude</code> discretizes both the control and the shape function to the midpoints of the <code>tlist</code> array.</p><pre><code class="language-julia hljs">using QuantumControl.Shapes: flattop

function guess_amplitudes(; T=400ns, E₀=35MHz, dt=0.1ns, t_rise=15ns)

    tlist = collect(range(0, T, step=dt))
    shape(t) = flattop(t, T=T, t_rise=t_rise)
    Ωre = ShapedAmplitude(t -&gt; E₀, tlist; shape)
    Ωim = ShapedAmplitude(t -&gt; 0.0, tlist; shape)

    return tlist, Ωre, Ωim

end

tlist, Ωre_guess, Ωim_guess = guess_amplitudes();</code></pre><p>We can visualize this:</p><pre><code class="language-julia hljs">using Plots
Plots.default(
    linewidth               = 3,
    size                    = (550, 300),
    legend                  = :right,
    foreground_color_legend = nothing,
    background_color_legend = RGBA(1, 1, 1, 0.8),
)
using QuantumControl.Controls: discretize

function plot_complex_pulse(tlist, Ω; time_unit=:ns, ampl_unit=:MHz, kwargs...)

    Ω = discretize(Ω, tlist)  # make sure Ω is defined on *points* of `tlist`

    ax1 = plot(
        tlist ./ eval(time_unit),
        abs.(Ω) ./ eval(ampl_unit);
        label=&quot;|Ω|&quot;,
        xlabel=&quot;time ($time_unit)&quot;,
        ylabel=&quot;amplitude ($ampl_unit)&quot;,
        kwargs...
    )

    ax2 = plot(
        tlist ./ eval(time_unit),
        angle.(Ω) ./ π;
        label=&quot;ϕ(Ω)&quot;,
        xlabel=&quot;time ($time_unit)&quot;,
        ylabel=&quot;phase (π)&quot;
    )

    plot(ax1, ax2, layout=(2, 1))

end

plot_complex_pulse(tlist, Array(Ωre_guess) .+ 𝕚 .* Array(Ωim_guess))</code></pre><img src="b7ec39ab.svg" alt="Example block output"/><p>We now instantiate the Hamiltonian with these control fields:</p><pre><code class="language-julia hljs">H = transmon_hamiltonian(Ωre=Ωre_guess, Ωim=Ωim_guess)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Generator{SparseArrays.SparseMatrixCSC{ComplexF64, Int64}, QuantumPropagators.Amplitudes.ShapedPulseAmplitude}(&lt;3 ops&gt;, &lt;2 amplitudes&gt;)</code></pre><h2 id="Logical-basis-for-two-qubit-gates"><a class="docs-heading-anchor" href="#Logical-basis-for-two-qubit-gates">Logical basis for two-qubit gates</a><a id="Logical-basis-for-two-qubit-gates-1"></a><a class="docs-heading-anchor-permalink" href="#Logical-basis-for-two-qubit-gates" title="Permalink"></a></h2><p>For simplicity, we will be define the qubits in the <em>bare</em> basis, i.e. ignoring the static coupling <span>$J$</span>.</p><pre><code class="language-julia hljs">function ket(i::Int64; N=N)
    Ψ = zeros(ComplexF64, N)
    Ψ[i+1] = 1
    return Ψ
end

function ket(indices::Int64...; N=N)
    Ψ = ket(indices[1]; N=N)
    for i in indices[2:end]
        Ψ = Ψ ⊗ ket(i; N=N)
    end
    return Ψ
end

function ket(label::AbstractString; N=N)
    indices = [parse(Int64, digit) for digit in label]
    return ket(indices...; N=N)
end;</code></pre><pre><code class="language-julia hljs">basis = [ket(&quot;00&quot;), ket(&quot;01&quot;), ket(&quot;10&quot;), ket(&quot;11&quot;)];</code></pre><h2 id="Optimizing-for-a-specific-quantum-gate"><a class="docs-heading-anchor" href="#Optimizing-for-a-specific-quantum-gate">Optimizing for a specific quantum gate</a><a id="Optimizing-for-a-specific-quantum-gate-1"></a><a class="docs-heading-anchor-permalink" href="#Optimizing-for-a-specific-quantum-gate" title="Permalink"></a></h2><p>Our target gate is <span>$\Op{O} = \sqrt{\text{iSWAP}}$</span>:</p><pre><code class="language-julia hljs">SQRTISWAP = [
    1  0    0   0
    0 1/√2 𝕚/√2 0
    0 𝕚/√2 1/√2 0
    0  0    0   1
];</code></pre><p>For each basis state, we get a target state that results from applying the gate to the basis state (you can convince yourself that this equivalent multiplying the transpose of the above gate matrix to the vector of basis states):</p><pre><code class="language-julia hljs">basis_tgt = transpose(SQRTISWAP) * basis;</code></pre><p>The mapping from each initial (basis) state to the corresponding target state constitutes an &quot;objective&quot; for the optimization:</p><pre><code class="language-julia hljs">objectives = [
    Objective(initial_state=Ψ, target_state=Ψtgt, generator=H) for
    (Ψ, Ψtgt) ∈ zip(basis, basis_tgt)
];</code></pre><p>We can analyze how all of the basis states evolve under the guess controls in one go:</p><pre><code class="language-julia hljs">guess_states = propagate_objectives(objectives, tlist; use_threads=true);</code></pre><p>The gate implemented by the guess controls is</p><pre><code class="language-julia hljs">U_guess = [basis[i] ⋅ guess_states[j] for i = 1:4, j = 1:4];</code></pre><p>We will optimize these objectives with a square-modulus functional</p><pre><code class="language-julia hljs">using QuantumControl.Functionals: J_T_sm</code></pre><p>The initial value of the functional is</p><pre><code class="language-julia hljs">J_T_sm(guess_states, objectives)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.9156372510988317</code></pre><p>which is the gate error</p><pre><code class="language-julia hljs">1 - (abs(tr(U_guess&#39; * SQRTISWAP)) / 4)^2</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.9156372510988317</code></pre><p>Now, we define the full optimization problems on top of the list of objectives, and with the optimization functional:</p><pre><code class="language-julia hljs">problem = ControlProblem(
    objectives=objectives,
    tlist=tlist,
    iter_stop=100,
    J_T=J_T_sm,
    check_convergence=res -&gt; begin
        (
            (res.J_T &gt; res.J_T_prev) &amp;&amp;
            (res.converged = true) &amp;&amp;
            (res.message = &quot;Loss of monotonic convergence&quot;)
        )
        ((res.J_T &lt;= 1e-3) &amp;&amp; (res.converged = true) &amp;&amp; (res.message = &quot;J_T &lt; 10⁻³&quot;))
    end,
    use_threads=true,
);</code></pre><pre><code class="language-julia hljs">opt_result = @optimize_or_load(datadir(&quot;GATE_OCT.jld2&quot;), problem; method=:GRAPE);</code></pre><pre><code class="language-julia hljs">opt_result</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">GRAPE Optimization Result
-------------------------
- Started at 2022-12-01T22:36:37.168
- Number of objectives: 4
- Number of iterations: 38
- Number of pure func evals: 0
- Number of func/grad evals: 43
- Value of functional: 6.92256e-04
- Reason for termination: J_T &lt; 10⁻³
- Ended at 2022-12-01T22:37:46.838 (1 minute, 9 seconds, 670 milliseconds)
</code></pre><p>We extract the optimized control field from the optimization result and plot the resulting amplitude.</p><p>The <code>optimized_controls</code> field of the <code>opt_results</code> contains the optimized controls <span>$ϵ(t)$</span>.</p><pre><code class="language-julia hljs">ϵ_opt = opt_result.optimized_controls[1] + 𝕚 * opt_result.optimized_controls[2];</code></pre><p>These must still be multiplied by the static shape <span>$S(t)$</span> that we set up for the guess amplitudes</p><pre><code class="language-julia hljs">Ω_opt = ϵ_opt .* discretize(Ωre_guess.shape, tlist)

plot_complex_pulse(tlist, Ω_opt)</code></pre><img src="85776ae6.svg" alt="Example block output"/><p>We then propagate the optimized control field to analyze the resulting quantum gate:</p><pre><code class="language-julia hljs">using QuantumControl.Controls: get_controls, substitute

opt_states = propagate_objectives(
    substitute(
        objectives,
        IdDict(zip(get_controls(objectives), opt_result.optimized_controls))
    ),
    tlist;
    use_threads=true
);</code></pre><p>The resulting gate is</p><pre><code class="language-julia hljs">U_opt = [basis[i] ⋅ opt_states[j] for i = 1:4, j = 1:4];</code></pre><p>and we can verify the resulting fidelity</p><pre><code class="language-julia hljs">(abs(tr(U_opt&#39; * SQRTISWAP)) / 4)^2</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.999307743714723</code></pre><h2 id="Optimizing-for-a-general-perfect-entangler"><a class="docs-heading-anchor" href="#Optimizing-for-a-general-perfect-entangler">Optimizing for a general perfect entangler</a><a id="Optimizing-for-a-general-perfect-entangler-1"></a><a class="docs-heading-anchor-permalink" href="#Optimizing-for-a-general-perfect-entangler" title="Permalink"></a></h2><p>We define the optimization with one objective for each of the four basis states:</p><pre><code class="language-julia hljs">objectives = [Objective(; initial_state=Ψ, generator=H) for Ψ ∈ basis];</code></pre><p>Note that we omit the <code>target_state</code> here. This is because we will be optimizing for an arbitrary perfect entangler, not for a specific quantum gate. Thus, there is no a-priori known target state to which the initial state must evolve.</p><p>The optimization is steered by the perfect entanglers distance measure <span>$D_{PE}$</span>, that is, the geometric distance of the quantum gate obtained from propagating the four basis states to the polyhedron of perfect entanglers in the Weyl chamber. Since the logical subspace defining the qubit is embedded in the larger Hilbert space of the transmon, there may be loss of population from the logical subspace. To counter this possibility in the optimization, we add a unitarity measure  to <span>$D_{PE}$</span>. The two terms are added with equal weight.</p><pre><code class="language-julia hljs">using TwoQubitWeylChamber: D_PE, gate_concurrence, unitarity
using QuantumControl.Functionals: gate_functional

J_T_PE = gate_functional(D_PE; unitarity_weight=0.5);</code></pre><p>The <code>gate_functional</code> routines used above converts the function <code>D_PE</code> that receives the gate <span>$Û$</span> as a 4×4 matrix into a functional of the correct from for the <code>QuantumControl.optimize</code> routine, which is a function of the propagated states.</p><p>We can check that for the guess pulse, we are not implementing a perfect entangler</p><pre><code class="language-julia hljs">gate_concurrence(U_guess)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.7773116198523428</code></pre><p>We find that the guess pulse produces a gate in the <code>W0*</code> region of the Weyl chamber:</p><pre><code class="language-julia hljs">using TwoQubitWeylChamber: weyl_chamber_region
weyl_chamber_region(U_guess)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&quot;W0*&quot;</code></pre><p>That is, the region of the Weyl chamber containing controlled-phase gates with a phase <span>$&gt; π$</span> (Weyl chamber coordinates <span>$c₁ &gt; π/2$</span>, <span>$c₂ &lt; π/4$</span>).</p><p>This in fact allows use to use the perfect entangler functional without modification: if the guess pulse were in the &quot;W1&quot; region of the Weyl chamber, (close to SWAP), we would have to flip its sign, or we would optimize towards the local equivalence class of the SWAP gate instead of towards the perfect of perfect entanglers. In principle, we could use a modified functional that takes the absolute square of the <code>D_PE</code> term, by using</p><pre><code class="nohighlight hljs">J_T_PE = gate_functional(D_PE; unitarity_weight=0.5, absolute_square=true)</code></pre><p>This would specifically optimize for the <em>surface</em> of the perfect entanglers functional.</p><p>The guess pulse loses about 10% of population from the logical subspace:</p><pre><code class="language-julia hljs">1 - unitarity(U_guess)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.09071664593785189</code></pre><p>We can also evaluate the geometric distance to the polyhedron of perfect entanglers in the Weyl chamber:</p><pre><code class="language-julia hljs">D_PE(U_guess)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.7787454222362598</code></pre><p>Together with the unitarity measure, this is the initial value of the optimization functional:</p><pre><code class="language-julia hljs">0.5 * D_PE(U_guess) + 0.5 * (1 - unitarity(U_guess))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.4347310340870558</code></pre><pre><code class="language-julia hljs">J_T_PE(guess_states, objectives)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.4347310340870558</code></pre><p>For the standard functional <code>J_T_sm</code> used in the previous section, our GRAPE was able to automatically use an analytic implementation of the gradient. For the perfect-entanglers functional, an analytic gradient exist, but is very cumbersome to implement. Instead, we make use of semi-automatic differentiation. As shown in Goerz et al., arXiv:2205.15044, by evaluating the gradient via a chain rule in the propagated states, the dependency of the gradient on the final time functional is pushed into the boundary condition for the backward propagation, <span>$|χ_k⟩ = -∂J_T/∂⟨ϕ_k|$</span>. We can further exploit that <code>J_T</code> is an explicit function of the two-qubit gate in the computational basis and use a chain rule with respect to the elements of the two-qubit gate <span>$U_{kk&#39;}$</span>. The remaining derivatives <span>$∂J_T/∂U_{kk&#39;}$</span> are then obtained via automatic differentiation. This is set up via the <code>make_gate_chi</code> function,</p><pre><code class="language-julia hljs">using QuantumControl.Functionals: make_gate_chi
chi_pe = make_gate_chi(D_PE, objectives; unitarity_weight=0.5);</code></pre><p>where the resulting <code>chi_pe</code> must be passed to the optimization.</p><p>Now, we formulate the full control problem</p><pre><code class="language-julia hljs">problem = ControlProblem(
    objectives=objectives,
    tlist=tlist,
    iter_stop=100,
    J_T=J_T_PE,
    chi=chi_pe,
    check_convergence=res -&gt; begin
        (
            (res.J_T &gt; res.J_T_prev) &amp;&amp;
            (res.converged = true) &amp;&amp;
            (res.message = &quot;Loss of monotonic convergence&quot;)
        )
        (
            (res.J_T &lt;= 1e-3) &amp;&amp;
            (res.converged = true) &amp;&amp;
            (res.message = &quot;Found a perfect entangler&quot;)
        )
    end,
    use_threads=true,
);</code></pre><p>With this, we can easily find a solution to the control problem:</p><pre><code class="language-julia hljs">opt_result = @optimize_or_load(datadir(&quot;PE_OCT.jld2&quot;), problem; method=:GRAPE);</code></pre><pre><code class="language-julia hljs">opt_result</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">GRAPE Optimization Result
-------------------------
- Started at 2022-12-01T22:37:49.858
- Number of objectives: 4
- Number of iterations: 8
- Number of pure func evals: 0
- Number of func/grad evals: 10
- Value of functional: -4.25769e-03
- Reason for termination: Found a perfect entangler
- Ended at 2022-12-01T22:38:12.221 (22 seconds, 363 milliseconds)
</code></pre><p>We extract the optimized control field from the optimization result and plot it</p><pre><code class="language-julia hljs">ϵ_opt = opt_result.optimized_controls[1] + 𝕚 * opt_result.optimized_controls[2]
Ω_opt = ϵ_opt .* discretize(Ωre_guess.shape, tlist)

plot_complex_pulse(tlist, Ω_opt)</code></pre><img src="4752cae2.svg" alt="Example block output"/><p>We then propagate the optimized control field to analyze the resulting quantum gate:</p><pre><code class="language-julia hljs">opt_states = propagate_objectives(
    substitute(
        objectives,
        IdDict(zip(get_controls(objectives), opt_result.optimized_controls))
    ),
    tlist;
    use_threads=true
);

U_opt = [basis[i] ⋅ opt_states[j] for i = 1:4, j = 1:4];</code></pre><p>We find that we have achieved a perfect entangler:</p><pre><code class="language-julia hljs">gate_concurrence(U_opt)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1.0</code></pre><p>Moreover, we have reduced the population loss to less than 4%</p><pre><code class="language-julia hljs">1 - unitarity(U_opt)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.035261694557666035</code></pre><h2 id="Direct-maximization-of-the-gate-concurrence"><a class="docs-heading-anchor" href="#Direct-maximization-of-the-gate-concurrence">Direct maximization of the gate concurrence</a><a id="Direct-maximization-of-the-gate-concurrence-1"></a><a class="docs-heading-anchor-permalink" href="#Direct-maximization-of-the-gate-concurrence" title="Permalink"></a></h2><p>In the previous optimizations, we have optimized for a perfect entangler indirectly via a geometric function in the Weyl chamber. The entire reason that perfect entangler functional was formulated is because calculating the gate concurrence directly involves the eigenvalues of the unitary, see <a href="../../references/#KrausPRA2001">Kraus and Cirac [5]</a> and <a href="../../references/#ChildsPRA2003">Childs *et al.* [6]</a>, which are inherently non-analytic.</p><p>However, since we are able to obtain gradient from automatic differentiation, this is no longer an insurmountable obstacle</p><p>We can define a functional for a given gate <code>U</code> that combines the gate concurrence and (as above) a unitarity measure to penalize loss of population from the logical subspace:</p><pre><code class="language-julia hljs">J_T_C(U) = 0.5 * (1 - gate_concurrence(U)) + 0.5 * (1 - unitarity(U));</code></pre><p>In the optimization, we will convert this functional to one that takes the propagated states as arguments (via the <code>gate_functional</code> routine). Also, as before, we have to create a matching routine for the boundary condition <span>$|χ_k⟩ = -\frac{∂}{∂⟨ϕ_k|} J_T$</span> of the backward-propagation via the <code>make_gate_chi</code> routine.</p><p>Running this, we again are able to find a perfect entangler.</p><pre><code class="language-julia hljs">opt_result_direct = @optimize_or_load(
    datadir(&quot;PE_OCT_direct.jld2&quot;),
    problem;
    method=:GRAPE,
    J_T=gate_functional(J_T_C),
    chi=make_gate_chi(J_T_C, objectives)
);</code></pre><pre><code class="language-julia hljs">opt_result_direct</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">GRAPE Optimization Result
-------------------------
- Started at 2022-12-01T22:38:13.078
- Number of objectives: 4
- Number of iterations: 13
- Number of pure func evals: 0
- Number of func/grad evals: 15
- Value of functional: 3.24322e-04
- Reason for termination: Found a perfect entangler
- Ended at 2022-12-01T22:38:45.940 (32 seconds, 862 milliseconds)
</code></pre><pre><code class="language-julia hljs">opt_states_direct = propagate_objectives(
    substitute(
        objectives,
        IdDict(zip(get_controls(objectives), opt_result_direct.optimized_controls))
    ),
    tlist;
    use_threads=true
);

U_opt_direct = [basis[i] ⋅ opt_states_direct[j] for i = 1:4, j = 1:4];</code></pre><pre><code class="language-julia hljs">gate_concurrence(U_opt_direct)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1.0</code></pre><pre><code class="language-julia hljs">1 - unitarity(U_opt_direct)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.000648643693457629</code></pre><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../simple_state_to_state/">« Example 1 (TLS)</a><a class="docs-footer-nextpage" href="../../api/">API »</a><div class="flexbox-break"></div><p class="footer-message"><a href="https://github.com/JuliaQuantumControl/GRAPE.jl">GRAPE.jl</a> v0.5.5 docs powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.1.0 on <span class="colophon-date" title="Friday 6 October 2023 19:36">Friday 6 October 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
