<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Background · GRAPE.jl</title><meta name="title" content="Background · GRAPE.jl"/><meta property="og:title" content="Background · GRAPE.jl"/><meta property="twitter:title" content="Background · GRAPE.jl"/><meta name="description" content="Documentation for GRAPE.jl."/><meta property="og:description" content="Documentation for GRAPE.jl."/><meta property="twitter:description" content="Documentation for GRAPE.jl."/><meta property="og:url" content="https://juliaquantumcontrol.github.io/GRAPE.jl/background/"/><meta property="twitter:url" content="https://juliaquantumcontrol.github.io/GRAPE.jl/background/"/><link rel="canonical" href="https://juliaquantumcontrol.github.io/GRAPE.jl/background/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/citations.css" rel="stylesheet" type="text/css"/><link href="https://juliaquantumcontrol.github.io/QuantumControl.jl/dev/assets/topbar/topbar.css" rel="stylesheet" type="text/css"/><script src="https://juliaquantumcontrol.github.io/QuantumControl.jl/dev/assets/topbar/topbar.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">GRAPE.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../usage/">Usage</a></li><li class="is-active"><a class="tocitem" href>Background</a><ul class="internal"><li><a class="tocitem" href="#Introduction"><span>Introduction</span></a></li><li><a class="tocitem" href="#tmidr"><span>Too Many Indices; Didn&#39;t Read</span></a></li><li><a class="tocitem" href="#Prerequisite:-Wirtinger-derivatives-and-matrix-calculus"><span>Prerequisite: Wirtinger derivatives and matrix calculus</span></a></li><li><a class="tocitem" href="#Gradients-for-final-time-functionals"><span>Gradients for final-time functionals</span></a></li><li><a class="tocitem" href="#Derivative-of-the-time-evolution-operator"><span>Derivative of the time-evolution operator</span></a></li><li><a class="tocitem" href="#GRAPE-scheme"><span>GRAPE scheme</span></a></li><li><a class="tocitem" href="#Overview-SemiAD"><span>Semi-automatic differentiation</span></a></li><li><a class="tocitem" href="#Overview-Running-Costs"><span>Running costs</span></a></li><li><a class="tocitem" href="#Optimizers"><span>Optimizers</span></a></li></ul></li><li><a class="tocitem" href="../api/">API</a></li><li><a class="tocitem" href="../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Background</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Background</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaQuantumControl/GRAPE.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaQuantumControl/GRAPE.jl/blob/master/docs/src/background.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="GRAPE-Background"><a class="docs-heading-anchor" href="#GRAPE-Background">Background</a><a id="GRAPE-Background-1"></a><a class="docs-heading-anchor-permalink" href="#GRAPE-Background" title="Permalink"></a></h1><p>We review here in detail the GRAPE method as it is implemented in <code>GRAPE.jl</code>. Much of the material is adapted from <a href="../references/#GoerzQ2022">Goerz <em>et al.</em>, Quantum 6, 871 (2022)</a>.</p><p><strong>Contents</strong></p><ul><li><a href="#Introduction">Introduction</a></li><li><a href="#tmidr">Too Many Indices; Didn&#39;t Read</a></li><li><a href="#Prerequisite:-Wirtinger-derivatives-and-matrix-calculus">Prerequisite: Wirtinger derivatives and matrix calculus</a></li><li class="no-marker"><ul><li><a href="#Wirtinger-Scalars">Derivatives w.r.t. complex scalars</a></li><li><a href="#Wirtinger-Vectors">Derivatives w.r.t. complex vectors</a></li><li><a href="#Complex-Gradient">Complex <code>gradient</code></a></li></ul></li><li><a href="#Gradients-for-final-time-functionals">Gradients for final-time functionals</a></li><li><a href="#Derivative-of-the-time-evolution-operator">Derivative of the time-evolution operator</a></li><li class="no-marker"><ul><li><a href="#Overview-Taylor">Taylor expansion</a></li><li><a href="#Overview-Gradgen">Gradient Generators</a></li></ul></li><li><a href="#GRAPE-scheme">GRAPE scheme</a></li><li><a href="#Overview-SemiAD">Semi-automatic differentiation</a></li><li><a href="#Overview-Running-Costs">Running costs</a></li><li class="no-marker"><ul><li><a href="#Field-dependent-running-costs">Field-dependent running costs</a></li><li><a href="#State-Dependent-Running-Costs">State-dependent running costs</a></li></ul></li><li><a href="#Optimizers">Optimizers</a></li></ul><h2 id="Introduction"><a class="docs-heading-anchor" href="#Introduction">Introduction</a><a id="Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction" title="Permalink"></a></h2><p>The GRAPE method minimizes an optimization functional of the form</p><p class="math-container">\[\begin{equation}\label{eq:grape-functional}
J(\{ϵ_l(t)\})
    = J_T(\{|Ψ_k(T)⟩\})
    + λ_a \, \underbrace{∑_l \int_{0}^{T} g_a(ϵ_l(t)) \, dt}_{=J_a(\{ϵ_l(t)\})}
    + λ_b \, \underbrace{∑_k \int_{0}^{T} g_b(|Ψ_k(t)⟩) \, dt}_{=J_b(\{|Ψ_k(t)⟩\})}\,,
\end{equation}\]</p><p>where <span>$\{ϵ_l(t)\}$</span> is a set of <a href="https://juliaquantumcontrol.github.io/QuantumControl.jl/dev/glossary/#Control-Function">control functions</a> defined between the initial time <span>$t=0$</span> and the final time <span>$t=T$</span>, and <span>$\{|Ψ_k(t)⟩\}$</span> is a set of <a href="https://juliaquantumcontrol.github.io/QuantumControl.jl/dev/api/reference/#QuantumControl.Trajectory">&quot;trajectories&quot;</a> evolving from a set of initial states <span>$\{|\Psi_k(t=0)⟩\}$</span> under the controls <span>$\{ϵ_l(t)\}$</span>. The primary focus is on the final-time functional <span>$J_T$</span>, but running costs <span>$J_a$</span> (weighted by <span>$λ_a$</span>) may be included to penalize certain features of the control field. In principle, a state-dependent running cost <span>$J_b$</span> weighted by <span>$λ_b$</span> can also be included (and will be discussed below), although this is currently not fully implemented in <code>GRAPE.jl</code>.</p><p>The defining assumptions of the GRAPE method are</p><ol><li><p>The control fields <span>$\epsilon_l(t)$</span> are piecewise constant on the <span>$N_T$</span> intervals of a time grid <span>$t_0 = 0, t_1, \dots t_{N_T} = T$</span>. That is, we have a vector of pulse values with elements <span>$\epsilon_{nl}$</span>. We use the double-index <code>nl</code>, for the value of the <span>$l$</span>&#39;th control field on the <span>$n$</span>&#39;th interval of the time grid. When the initial controls are time-continuous, for the purposes of <code>GRAPE.jl</code>, they are first discretized via <a href="https://juliaquantumcontrol.github.io/QuantumPropagators.jl/dev/api/quantumpropagators/#QuantumPropagators.Controls.discretize_on_midpoints"><code>QuantumPropagators.Controls.discretize_on_midpoints</code></a>. The optimized fields are always vectors of pulse values.</p></li><li><p>The states <span>$|\Psi_k(t)⟩$</span> evolve under an equation of motion of the form</p><p class="math-container">\[\begin{equation}\label{eq:tdse}
    i \hbar \frac{\partial |\Psi_k(t)⟩}{\partial t} = \hat{H}_k(\{\epsilon_l(t)\}) |\Psi_k(t)⟩\,,
\end{equation}\]</p><p>with <span>$\hbar = 1$</span> (we will omit <span>$\hbar$</span> in all subsequent equations).</p><p>This includes the Schrödinger equation, but also the Liouville equation for open quantum systems. In the latter case, <span>$|\Psi_k⟩$</span> is replaced by a vectorized density matrix, and <span>$\hat{H}_k$</span> is replaced by a Liouvillian (super-) operator describing the dynamics of the <span>$k$</span>&#39;th trajectory. The crucial point is that Eq. \eqref{eq:tdse} can be solved within each time interval as</p><p class="math-container">\[\begin{equation}\label{eq:time-evolution-op}
    \def\ii{\mathrm{i}}
    |\Psi_k(t_{n+1})⟩ = \underbrace{\exp\left[-\ii \hat{H}_{kn} dt_n \right]}_{=\hat{U}^{(k)}_{n}} |\Psi_k(t_n)⟩\,,
\end{equation}\]</p><p>where <span>$\hat{H}_{kn} = \hat{H}_k(\{\epsilon_{nl}\})$</span> is <span>$\hat{H}_k(\{\epsilon_l(t)\})$</span> evaluated at the midpoint of the <span>$n$</span>&#39;th interval (respectively at <span>$t=0$</span> and <span>$t=T$</span> for <span>$n=1$</span> and <span>$n=N_T$</span>), and with the time step <span>$dt_n = (t_n - t_{n-1})$</span>.</p></li></ol><p>These two assumptions allow to analytically derive the gradient <span>$(\nabla J)_{nl} \equiv \frac{\partial J}{\partial \epsilon_{nl}}$</span>. The initial derivation of GRAPE by <a href="../references/#KhanejaJMR2005">Khaneja <em>et al.</em> [1]</a> focuses on a final-time functional <span>$J_T$</span> that depends on the overlap of each forward-propagated <span>$|\Psi_k(T)⟩$</span> with a target state <span>$|\Psi^{\text{tgt}}_k(T)⟩$</span> and updates the pulse values <span>$\epsilon_{nl}$</span> directly in the direction of the negative gradient. Improving on this, <a href="../references/#FouquieresJMR2011">de Fouquières <em>et al.</em> [2]</a> showed that using a quasi-Newton method to update the pulses based on the gradient information leads to a dramatic improvement in convergence and stability. Furthermore, <a href="../references/#GoodwinJCP2015">Goodwin and Kuprov [5]</a> improved on the precision of evaluating the gradient of a local time evolution operator, which is a critical step in the GRAPE scheme. Finally, <a href="../references/#GoerzQ2022">Goerz <em>et al.</em> [3]</a> generalized GRAPE to arbitrary functionals of the form \eqref{eq:grape-functional}, bridging the gap to automatic differentiation techniques [<a href="../references/#LeungPRA2017">23</a>–<a href="../references/#AbdelhafezPRA2020">25</a>] by introducing the idea of &quot;semi-automatic differentiation&quot;. This most general derivation is the basis for the implementation in <code>GRAPE.jl</code>.</p><h2 id="tmidr"><a class="docs-heading-anchor" href="#tmidr">Too Many Indices; Didn&#39;t Read</a><a id="tmidr-1"></a><a class="docs-heading-anchor-permalink" href="#tmidr" title="Permalink"></a></h2><div class="admonition is-success" id="TMIDR-9f1f5140a5768f95"><header class="admonition-header">TMIDR<a class="admonition-anchor" href="#TMIDR-9f1f5140a5768f95" title="Permalink"></a></header><div class="admonition-body"><p>Below, we derive the GRAPE scheme in full generality. This implies keeping track of a lot of indices:</p><ul><li><span>$k$</span>: the index over the different <a href="https://juliaquantumcontrol.github.io/QuantumControl.jl/dev/api/reference/#QuantumControl.Trajectory">trajectories</a>, i.e., the states <span>$|\Psi_k(t)⟩$</span> whose time evolution contributes to the functional</li><li><span>$l$</span>: the index over the different <a href="https://juliaquantumcontrol.github.io/QuantumControl.jl/dev/glossary/#Control-Function">control functions</a> <span>$\epsilon_l(t)$</span> that the Hamiltonian/Liouvillian may depend on</li><li><span>$n$</span>: The index over the intervals of the time grid</li></ul><p>Most equations can be simplified by not worrying about <span>$k$</span> or <span>$l$</span>: If there are multiple controls, they are concatenated into a single vector of control values with a double-index <span>$nl$</span>. We really only need to keep track of <span>$n$</span>; the gradient values related to an <span>$\epsilon_{nl}$</span> with a particular <span>$l$</span> are somewhat obviously obtained by using a particular <span>$\epsilon_l(t_n)$</span>. Likewise, all trajectories contribute equally to the gradients, so we just have a sum over the <span>$k$</span> index.</p><p>We can further simplify by considering only final-time functionals <span>$J_T(\{|\Psi_k(T)⟩\})$</span>. Running costs <span>$J_a(\{ϵ_l(t)\})$</span> are quite straightforward to add (just take the derivative w.r.t. the values <span>$ϵ_{nl}$</span>), and running costs <span>$J_b(\{|Ψ_k(t)⟩\})$</span> are <a href="#State-Dependent-Running-Costs">too complicated</a> to consider in any kind of &quot;simplified&quot; scheme.</p><p>In essence, then, the GRAPE scheme that is implemented here can be concisely summarized as</p><p class="math-container">\[\begin{equation}
\frac{\partial J_T}{\partial \epsilon_{n}}
= -2 \Re
   \underbrace{%
       \underbrace{\bigg\langle \chi(T) \bigg\vert \hat{U}_{N_T} \dots \hat{U}_{n+1} \bigg \vert}_{\equiv \bra{\chi(t_n)}\;\text{(bw. prop.)}}
       \frac{\partial \hat{U}_n}{\partial \epsilon_{n}}
   }_{\equiv \bra{\chi^\prime(t_{n-1})}}
   \underbrace{\bigg \vert \hat{U}_{n-1} \dots \hat{U}_1 \bigg\vert \Psi(t=0) \bigg\rangle}_{\equiv |\Psi(t_{n-1})⟩\;\text{(fw. prop.)}}\,,
\end{equation}\]</p><p>cf. Eq. \eqref{eq:grad-at-T-U}, with the boundary condition, cf. Eq. \eqref{eq:chi},</p><p class="math-container">\[\begin{equation}
    |\chi(T)⟩ \equiv - \frac{\partial J_T}{\partial ⟨\Psi(T)|}\,.
\end{equation}\]</p><p>The gradient-state <span>$|\chi^\prime(t_{n-1})⟩$</span> is obtained either via an expansion of <span>$\hat{U}_n$</span> <a href="#Overview-Taylor">into a Taylor series</a>, or (by default), by backward-propagating an <a href="#Overview-Gradgen">extended state <span>$|\tilde\chi(t)⟩$</span> with gradient information</a> [<a href="../references/#GoodwinJCP2015">5</a>]. The resulting scheme is illustrated in <a href="#fig-grape-scheme">Fig. 1</a>.</p></div></div><h2 id="Prerequisite:-Wirtinger-derivatives-and-matrix-calculus"><a class="docs-heading-anchor" href="#Prerequisite:-Wirtinger-derivatives-and-matrix-calculus">Prerequisite: Wirtinger derivatives and matrix calculus</a><a id="Prerequisite:-Wirtinger-derivatives-and-matrix-calculus-1"></a><a class="docs-heading-anchor-permalink" href="#Prerequisite:-Wirtinger-derivatives-and-matrix-calculus" title="Permalink"></a></h2><p>Even though we are seeking the derivative of the real-valued functional <span>$J$</span> with respect to the real-valued parameter <span>$\epsilon_{nl}$</span>, the functional still involves complex quantities via <span>$|\Psi_k(t)⟩$</span> and <span>$\hat{H}$</span> in Eq. \eqref{eq:tdse}. In order to apply the chain rule in the derivation of the gradient, we will have to clarify the notion of derivatives in the context of complex numbers, as well as derivatives with respect to vectors (&quot;matrix calculus&quot;).</p><h3 id="Wirtinger-Scalars"><a class="docs-heading-anchor" href="#Wirtinger-Scalars">Derivatives w.r.t. complex scalars</a><a id="Wirtinger-Scalars-1"></a><a class="docs-heading-anchor-permalink" href="#Wirtinger-Scalars" title="Permalink"></a></h3><p>To illustrate, let&#39;s say we introduce intermediary scalar variables <span>$z_k \in \mathbb{C}$</span> in the functional, <span>$J(\{\epsilon_{nl}\}) \rightarrow J(\{z_k(\{\epsilon_{nl}\})\})$</span>, with <span>$J, \epsilon_{nl} \in \mathbb{R}$</span>.</p><p>In principle, one must separate the <span>$z_k$</span> into real and imaginary parts as independent variables, <span>$J = J(\{\Re[z_k]\}, \{\Im[z_k]\})$</span>, resulting in</p><p class="math-container">\[\begin{equation}
  \label{eq:grad_zj_real_imag}
  (\nabla J)_{nl}
  \equiv \frac{\partial J}{\partial \epsilon_{nl}}
  = \sum_k \left(
    \frac{\partial J}{\partial \Re[z_k]}
    \frac{\partial \Re[z_k]}{\partial \epsilon_{nl}}
    + \frac{\partial J}{\partial \Im[z_k]}
    \frac{\partial \Im[z_k]}{\partial \epsilon_{nl}}
    \right)\,.
\end{equation}\]</p><p>An elegant alternative is to introduce <a href="https://en.wikipedia.org/wiki/Wirtinger_derivatives">Wirtinger derivatives</a>,</p><p class="math-container">\[\begin{align}%
  \label{eq:wirtinger1}
  \frac{\partial J}{\partial z_k}
    &amp;\equiv \frac{1}{2} \left(
      \frac{\partial J}{\partial \Re[z_k]}
      -\ii \frac{\partial J}{\partial \Im[z_k]}
      \right)\,, \\
  \label{eq:wirtinger2}
  \frac{\partial J}{\partial z_k^*}
    &amp;\equiv \frac{1}{2} \left(
      \frac{\partial J}{\partial \Re[z_k]}
      +\ii \frac{\partial J}{\partial \Im[z_k]}
      \right)
    = \left(\frac{\partial J}{\partial z_k}\right)^*\,,
\end{align}\]</p><p>which instead treats <span>$z_k$</span> and the conjugate value <span>$z_k^*$</span> as independent variables, so that</p><p class="math-container">\[\begin{equation}%
  \label{eq:wirtinger-chainrule}
  \frac{\partial J}{\partial \epsilon_{nl}}
  = \sum_k \left(
    \frac{\partial J}{\partial z_k}
    \frac{\partial z_k}{\partial \epsilon_{nl}}
    + \frac{\partial J}{\partial z_k^*}
    \frac{\partial z_k^*}{\partial \epsilon_{nl}}
    \right)
  = 2 \Re \sum_k \frac{\partial J}{\partial z_k}
    \frac{\partial z_k}{\partial \epsilon_{nl}}
    \,.
\end{equation}\]</p><p>So, we have a simple chain rule, modified only by <span>$2 \Re[…]$</span>, where we can otherwise &quot;forget&quot; that <span>$z_k$</span> is a complex variable. The fact that <span>$J$</span> is real-valued guarantees that <span>$z_k$</span> and <span>$z_k^*$</span> can only occur in such ways that we don&#39;t have to worry about having &quot;lost&quot; <span>$z_k^*$</span>.</p><p>The derivative of the complex value <span>$z_k$</span> with respect to the real value <span>$\epsilon_{nl}$</span> is defined straightforwardly as</p><p class="math-container">\[\begin{equation}
  \frac{\partial z_k}{\partial \epsilon_{nl}}
  \equiv
  \frac{\partial \Re[z_k]}{\partial \epsilon_{nl}}
  + \ii \frac{\partial \Im[z_k]}{\partial \epsilon_{nl}}\,.
\end{equation}\]</p><h3 id="Wirtinger-Vectors"><a class="docs-heading-anchor" href="#Wirtinger-Vectors">Derivatives w.r.t. complex vectors</a><a id="Wirtinger-Vectors-1"></a><a class="docs-heading-anchor-permalink" href="#Wirtinger-Vectors" title="Permalink"></a></h3><p>We can now go one step further and allow for intermediate variables that are complex <em>vectors</em> instead of scalars, <span>$J(\{\epsilon_{nl}\}) \rightarrow J(\{|\Psi_k(\{\epsilon_{nl}\})⟩\})$</span>. Taking the derivative w.r.t. a vector puts us in the domain of <a href="https://en.wikipedia.org/wiki/Matrix_calculus">matrix calculus</a>. Fundamentally, the derivative of a scalar with respect to a (column) vector is a (row) vector consisting of the derivatives of the scalar w.r.t. the components of the vector, and the derivative of a vector w.r.t. a scalar is the obvious vector of derivatives.</p><p>Usually, matrix calculus assumes real-valued vectors, but the extension to complex vectors via the Wirtinger derivatives discussed above is relatively straightforward. The use of <a href="https://en.wikipedia.org/wiki/Bra–ket_notation">Dirac (&quot;braket&quot;) notation</a> helps tremendously here: <span>$|\Psi_k⟩$</span> describes a complex column vector, and <span>$⟨\Psi_k|$</span> describes the corresponding row vector with complex-conjugated elements. These can take the place of <span>$z_k$</span> and <span>$z_k^*$</span> in the Wirtinger derivative. Consider, e.g.,</p><p class="math-container">\[\begin{equation}\label{eq:Jsm}
J(\{|\Psi_k⟩\})
= \sum_k \vert \langle \Psi_k \vert \Psi_k^{\text{tgt}} \rangle \vert^2
= \sum_k \langle \Psi_k \vert \Psi_k^{\text{tgt}} \rangle \langle \Psi_k^{\text{tgt}} \vert \Psi_k \rangle\,,
\end{equation}\]</p><p>for a fixed set of &quot;target states&quot; <span>$|\Psi_k^{\text{tgt}}⟩$</span>.</p><p>The derivative <span>$\partial J/\partial |\Psi_k⟩$</span> is</p><p class="math-container">\[\begin{equation}\label{eq:dJ_dKet}
\frac{\partial J}{\partial |\Psi_k⟩} = \langle \Psi_k \vert \Psi_k^{\text{tgt}} \rangle \langle\Psi_k^{\text{tgt}}\vert\,,
\end{equation}\]</p><p>in the same sense as Eq. \eqref{eq:wirtinger1}. We simply treat <span>$|\Psi_k⟩$</span> and <span>$⟨\Psi_k|$</span> as independent variables corresponding to <span>$z_k$</span> and <span>$z_k^*$</span>. Note that the result is a &quot;bra&quot;, that is, a co-state, or <em>row vector</em>. The braket notation resolves the question of <a href="https://en.wikipedia.org/wiki/Matrix_calculus#Layout_conventions">&quot;layout conventions&quot;</a> in matrix calculus in favor of the &quot;numerator layout&quot;. Consequently, we also have a well-defined derivative w.r.t. the co-state:</p><p class="math-container">\[\begin{equation}
\frac{\partial J}{\partial ⟨\Psi_k|} = \langle \Psi_k^{\text{tgt}} \vert \Psi_k \rangle \vert\Psi_k^{\text{tgt}}\rangle\,,
\end{equation}\]</p><p>which we can either get explicitly from Eq. \eqref{eq:Jsm}, differentiating w.r.t. <span>$|\Psi_k⟩$</span> as an independent variable (and reordering the terms), or implicitly by taking the conjugate transpose of Eq. \eqref{eq:dJ_dKet}.</p><p>For the full chain rule of a functional <span>$J(\{|\Psi_k(\{\epsilon_{nl}\})⟩\})$</span>, we thus find</p><p class="math-container">\[\begin{equation}\label{eq:grad-via-chi1}
  (\nabla J)_{nl}
  \equiv \frac{\partial J}{\partial \epsilon_{nl}}
  = 2 \Re \sum_k \left(
    \frac{\partial J}{\partial |\Psi_k⟩}
    \frac{\partial |\Psi_k⟩}{\partial \epsilon_{nl}}
  \right)\,.
\end{equation}\]</p><p>With the definition in Eq. \eqref{eq:wirtinger1}, this corresponds directly to the scalar</p><p class="math-container">\[\begin{equation}
  \frac{\partial J}{\partial \epsilon_{nl}}
  = \sum_{km} \left(
    \frac{\partial J}{\partial \Re[\Psi_{km}]}
    \frac{\partial \Re[\Psi_{km}]}{\partial \epsilon_{nl}}
    + \frac{\partial J}{\partial \Im[\Psi_{km}]}
    \frac{\partial \Im[\Psi_{km}]}{\partial \epsilon_{nl}}
  \right)\,,
\end{equation}\]</p><p>where the complex scalar <span>$\Psi_{km}$</span> is the <span>$m$</span>&#39;th element of the <span>$k$</span>&#39;th vector, and corresponds to the <span>$z_k$</span> in Eq. \eqref{eq:wirtinger-chainrule}.</p><div class="admonition is-success" id="Open-Quantum-Systems-49fc4ac01793ed7a"><header class="admonition-header">Open Quantum Systems<a class="admonition-anchor" href="#Open-Quantum-Systems-49fc4ac01793ed7a" title="Permalink"></a></header><div class="admonition-body"><p>In open quantum systems, where the state is described by a density matrix <span>$\hat{\rho}$</span>, it can be helpful to adopt the double-braket notation <span>$\langle\!\langle \hat{\rho}_1 \vert \hat{\rho}_2 \rangle\!\rangle \equiv \tr[\hat{\rho}_1^\dagger \hat{\rho}_2]$</span>, respectively to keep track of normal states <span>$\hat{\rho}$</span> (corresponding to <span>$|\Psi⟩$</span>) and adjoint states <span>$\hat{\rho}^\dagger$</span> (corresponding to <span>$⟨\Psi|$</span>), even when <span>$\hat{\rho}$</span> is Hermitian and thus <span>$\hat{\rho} = \hat{\rho}^\dagger$</span>. For numerical purposes, density matrices are best vectorized by concatenating the columns of <span>$\hat{\rho}$</span> into a single column vector <span>$\vec{\rho}$</span>. Thus, we do not have to be concerned with a separate definition of derivatives w.r.t. density matrices.</p></div></div><h3 id="Complex-Gradient"><a class="docs-heading-anchor" href="#Complex-Gradient">Complex <code>gradient</code></a><a id="Complex-Gradient-1"></a><a class="docs-heading-anchor-permalink" href="#Complex-Gradient" title="Permalink"></a></h3><div class="admonition is-warning" id="Warning-ee38484323c50c5"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-ee38484323c50c5" title="Permalink"></a></header><div class="admonition-body"><p>Software frameworks for automatic differentiation such as <a href="https://github.com/FluxML/Zygote.jl">Zygote</a> [<a href="../references/#Zygote">26</a>] and <a href="https://www.tensorflow.org">Tensorflow</a> [<a href="../references/#Tensorflow">27</a>] may define a (mathematically questionable [<a href="../references/#Petersen2008">28</a>]) <a href="https://fluxml.ai/Zygote.jl/dev/complex/#Complex-Differentiation">&quot;gradient&quot;</a> of a real-valued function <span>$J$</span> with respect to a complex vector with elements <span>$z_j$</span> as</p><p class="math-container">\[\begin{equation}\label{eq:complex-gradient}
(\nabla_{z} J)_j
\equiv \frac{\partial J}{\partial \Re[z_j]} + \ii \frac{\partial J}{\partial \Im[z_j]}\,.
\end{equation}\]</p><p>This differs from the Wirtinger derivatives by a factor of two (and the complex conjugate). Thus,</p><p class="math-container">\[\begin{equation}\label{eq:wirtinger-zygote-grad}
\frac{\partial J}{\partial z_j} = \frac{1}{2} (\nabla_{z} J)^*_j
\end{equation}\]</p><p>in Eq. \eqref{eq:wirtinger-chainrule}, respectively Eq. \eqref{eq:grad-via-chi1} when using, e.g., the <a href="https://fluxml.ai/Zygote.jl/dev/#Zygote.gradient"><code>Zygote.gradient</code></a> function.</p></div></div><h2 id="Gradients-for-final-time-functionals"><a class="docs-heading-anchor" href="#Gradients-for-final-time-functionals">Gradients for final-time functionals</a><a id="Gradients-for-final-time-functionals-1"></a><a class="docs-heading-anchor-permalink" href="#Gradients-for-final-time-functionals" title="Permalink"></a></h2><p>For simplicity, we consider a functional defined entirely at final time <span>$T$</span>, the <span>$J_T$</span> term in Eq. \eqref{eq:grape-functional}. Since <span>$J_T$</span> depends explicitly on <span>$\{|\Psi_k(T)⟩\}$</span> and only implicitly on <span>$\{\epsilon_{nl}\}$</span>, we can use the complex chain rule in Eq. \eqref{eq:grad-via-chi1}.</p><p>Further, we define a new state</p><p class="math-container">\[\begin{equation}\label{eq:chi}
|\chi_k(T)⟩ \equiv - \frac{\partial J_T}{\partial ⟨\Psi_k(T)|}
\end{equation}\]</p><p>The minus sign in this definition is arbitrary, and is intended solely to match an identical definition in <a href="https://juliaquantumcontrol.github.io/Krotov.jl/dev/">Krotov&#39;s method</a>, the most direct alternative to GRAPE. Since <span>$|\chi_k(T)⟩$</span> does not depend on <span>$\epsilon_{nl}$</span>, we can pull forward the derivative <span>$\partial / \partial \epsilon_{nl}$</span> in Eq. \eqref{eq:grad-via-chi1}, writing it as</p><p class="math-container">\[\begin{equation}\label{eq:grad-at-T}
(\nabla J_T)_{nl}
= \frac{\partial J_T}{\partial \epsilon_{nl}}
= - 2 \Re \sum_k \frac{\partial}{\partial \epsilon_{nl}} \langle \chi_k(T) \vert \Psi_k(T)\rangle\,.
\end{equation}\]</p><p>We end up with the gradient of <span>$J_T$</span> being the derivative of the overlap of two states <span>$|\chi_k(T)⟩$</span> and <span>$|\Psi_k(T)⟩$</span> at final time <span>$T$</span>.</p><p>Next, we make use of the assumption that the time evolution is piecewise constant, so that we can use the time evolution operator defined in Eq. \eqref{eq:time-evolution-op} to write <span>$|\Psi_k(T)⟩$</span> as the time evolution of an initial state <span>$\Psi_k(t=0)$</span>, the <code>initial_state</code> of the <span>$k$</span>&#39;th <a href="https://juliaquantumcontrol.github.io/QuantumControl.jl/dev/api/reference/#QuantumControl.Trajectory"><code>trajectory</code></a> in the <a href="https://juliaquantumcontrol.github.io/QuantumControl.jl/dev/api/reference/#QuantumControl.ControlProblem"><code>QuantumControl.ControlProblem</code></a>. That is, <span>$|\Psi_k(T)⟩ = \hat{U}^{(k)}_{N_T} \dots \hat{U}^{(k)}_1 |\Psi_k(t=0)⟩$</span> with the time evolution operator <span>$\hat{U}^{(k)}_n$</span> for the <span>$n$</span>&#39;th time interval of the time grid with <span>$N_T + 1$</span> time grid points, cf. Eq. \eqref{eq:time-evolution-op}. Plugging this into Eq. \eqref{eq:grad-at-T} immediately gives us</p><p class="math-container">\[\begin{equation}\label{eq:grad-at-T-U}
\begin{split}
\frac{\partial J_T}{\partial \epsilon_{nl}}
&amp;= -2 \Re \sum_k \frac{\partial}{\partial \epsilon_{nl}}
    \bigg\langle \chi_k(T) \bigg\vert \hat{U}_{N_T}^{(k)} \dots \hat{U}^{(k)}_n \dots \hat{U}^{(k)}_1 \bigg\vert \Psi_k(t=0) \bigg\rangle
    \\
&amp;= -2 \Re \sum_k \bigg\langle \chi_k(t_{n}) \bigg\vert \frac{\partial \hat{U}^{(k)}_n}{\partial \epsilon_{nl}} \bigg\vert \Psi_k(t_{n-1}) \bigg\rangle
\end{split}
\end{equation}\]</p><p>with</p><p class="math-container">\[\begin{equation}
|\chi_k(t_{n})⟩ = U^{\dagger (k)}_{n+1} \dots U^{\dagger(k)}_{N_T} |\chi_k(T)⟩\,,
\end{equation}\]</p><p>i.e., a backward propagation of the state given by Eq. \eqref{eq:chi} with the adjoint Hamiltonian or Liouvillian, and</p><p class="math-container">\[\begin{equation}\label{eq:psi-time-evolution}
|\Psi_k(t_{n-1})⟩ = \hat{U}^{(k)}_{n-1}\dots \hat{U}^{(k)}_1 |\Psi_k(0)⟩\,,
\end{equation}\]</p><p>i.e., a forward propagation of the initial state of the <span>$k$</span>&#39;th trajectory.</p><h2 id="Derivative-of-the-time-evolution-operator"><a class="docs-heading-anchor" href="#Derivative-of-the-time-evolution-operator">Derivative of the time-evolution operator</a><a id="Derivative-of-the-time-evolution-operator-1"></a><a class="docs-heading-anchor-permalink" href="#Derivative-of-the-time-evolution-operator" title="Permalink"></a></h2><p>The last missing piece for evaluating the gradient in Eq. \eqref{eq:grad-at-T-U} is the derivative of the time evolution operator <span>$\hat{U}_n^{(k)}$</span> for the current time interval <span>$n$</span>. The operator <span>$\frac{\partial \hat{U}_n^{(k)}}{\partial \epsilon_{nl}}$</span> could either act to the right, being applied to <span>$|\Psi_k(t_{n-1})⟩$</span> during the forward propagation, or it (or rather its conjugate transpose) could act to the left, being applied to <span>$|\chi_k(t_n)⟩$</span> during the backward propagation. For reasons that will be explained later on, it is numerically more efficient to include it in the backward propagation. Thus, we are given a state <span>$|\chi_k(t_{n})⟩$</span> and must then numerically obtain the state</p><p class="math-container">\[\begin{equation}\label{eq:U-deriv}
|\chi^\prime_{kl}(t_{n-1})⟩
\equiv  \frac{\partial \hat{U}^{\dagger(k)}_n}{\partial \epsilon_{nl}} |\chi_k(t_n)⟩
= \frac{\partial}{\partial \epsilon_{nl}} \exp\left[-\ii \hat{H}^{\dagger}_{k}(\{\epsilon_{nl}\}) dt^{(-)}_n \right] |\chi_k(t_n)⟩\,.
\end{equation}\]</p><p>Note the dagger and the negative time step <span>$dt^{(-)}_n = (t_{n-1} - t_{n})$</span> — in lieu of changing the sign of the imaginary unit <span>$\ii$</span> — to account for the fact that we are doing a backward propagation, cf. the corresponding forward propagation in Eq. \eqref{eq:time-evolution-op}. Of course, for a standard Schrödinger equation, <span>$\hat{H}_{kn}^\dagger = \hat{H}_{kn}$</span>, and then the negative time step is the only difference between backward and forward propagation; but, in general, we also allow for non-Hermitian Hamiltonians or Liouvillians where it is important to use the correct (adjoint) operator.</p><p>Thus, Eq. \eqref{eq:grad-at-T-U} turns into</p><p class="math-container">\[\begin{equation}\label{eq:grad-via-chi-prime}
\frac{\partial J_T}{\partial \epsilon_{nl}}
= -2 \Re \sum_k \bigg \langle \chi^\prime_{kl}(t_{n-1}) \bigg\vert \Psi_k(t_{n-1}) \bigg \rangle\,.
\end{equation}\]</p><p>Or, equivalently, if we had let <span>$\frac{\partial \hat{U}_n^{(k)}}{\partial \epsilon_{nl}}$</span> act to the right,</p><p class="math-container">\[\begin{equation}\label{eq:grad-via-psi-prime}
\frac{\partial J_T}{\partial \epsilon_{nl}}
= -2 \Re \sum_k \bigg \langle \chi_{kl}(t_{n}) \bigg\vert \Psi^{\prime}_k(t_{n}) \bigg \rangle\,.
\end{equation}\]</p><p>with <span>$|\Psi^{\prime}_k(t_{n})⟩ \equiv  \frac{\partial \hat{U}^{(k)}_n}{\partial \epsilon_{nl}} |\Psi_k(t_{n-1})⟩$</span>.</p><h3 id="Overview-Taylor"><a class="docs-heading-anchor" href="#Overview-Taylor">Taylor expansion</a><a id="Overview-Taylor-1"></a><a class="docs-heading-anchor-permalink" href="#Overview-Taylor" title="Permalink"></a></h3><p>There are several possibilities for evaluating Eq. \eqref{eq:U-deriv}. One method is to expand the exponential into a Taylor series [<a href="../references/#KuprovJCP2009">22</a>, Eq. (20)]</p><p class="math-container">\[\begin{equation}\label{eq:taylor-op}
\frac{\partial \hat{U}^{\dagger(k)}_n}{\partial \epsilon_{nl}}
= \sum_{m=1}^{\infty} \frac{\left(-\ii \hat{H}^{\dagger}_{kn} dt^{(-)}_n\right)^m}{m!}
    \sum_{m^\prime=0}^{m-1}
    {\hat{H}^{\dagger}_{kn}}^{\!\!m^\prime}
    \hat{\mu}_{lkn}^{\dagger}
    {\hat{H}^{\dagger}_{kn}}^{\!\!m-m^\prime-1}
\end{equation}\]</p><p>with <span>$\hat{H}_{kn} \equiv \hat{H}_{k}(\{\epsilon_{nl}\})$</span> and <span>$\hat{\mu}_{lkn} \equiv \frac{\partial \hat{H}_{kn}}{\partial \epsilon_{nl}}$</span>.</p><p>In practice, Eq. \eqref{eq:taylor-op} is best evaluated recursively, while being applied to <span>$|\chi_k(t_n)⟩$</span>:</p><p class="math-container">\[\begin{equation}
|\chi^\prime_{kl}(t_{n-1})⟩ = \sum_{m=1}^{\infty} \frac{\left(-\ii \, dt_n^{(-)}\right)^m}{m!} |\Phi^{(lkn)}_m⟩\,,
\end{equation}\]</p><p>with</p><p class="math-container">\[\begin{equation}
\begin{split}
  |\Phi^{(lkn)}_1⟩ &amp;= \hat{\mu}_{lkn}^{\dagger} |\chi_k(t_n)⟩\,,              \\
  |\Phi^{(lkn)}_m⟩ &amp;= \hat{\mu}_{lkn}^{\dagger} {\hat{H}^{\dagger}_{kn}}^{\!\!m-1}  |\chi_k(t_n)⟩ + {\hat{H}^{\dagger}_{kn}} |\Phi^{(lkn)}_{m-1}⟩\,.
\end{split}
\end{equation}\]</p><p>In <code>GRAPE.jl</code>, Eq. \eqref{eq:U-deriv} can be evaluated via a Taylor expansion as described above by passing <code>gradient_method=:taylor</code>, with further options to limit the maximum order <span>$m$</span>.</p><div class="admonition is-success" id="TMIDR-353f5fccbd72869a"><header class="admonition-header">TMIDR<a class="admonition-anchor" href="#TMIDR-353f5fccbd72869a" title="Permalink"></a></header><div class="admonition-body"><p>As in the <a href="#tmidr">general TMIDR</a>, the indices <span>$k$</span> and <span>$l$</span> are somewhat superfluous here. In addition, <span>$\hat{\mu}_{lkn} \equiv \frac{\partial \hat{H}_{kn}}{\partial \epsilon_{nl}}$</span> still depends on <span>$\epsilon_{nl}$</span> only for non-linear controls. Much more commonly, for linear Hamiltonians of the form <span>$\hat{H} = \hat{H_0} + \epsilon(t) \hat{\mu}$</span>, the derivative <span>$\hat{\mu}$</span> is just a static <a href="https://juliaquantumcontrol.github.io/QuantumControl.jl/dev/glossary/#Control-Operator">control operator</a>. If <span>$\hat{H}$</span> is a standard Hamiltonian, and thus Hermitian, we can drop the dagger. The time grid is usually uniform, so we can drop the index <span>$n$</span> from <span>$dt$</span>. Thus, a simplified version of Eq. \eqref{eq:taylor-op} is</p><p class="math-container">\[\begin{equation}\label{eq:taylor-op-simplified}
\frac{\partial \hat{U}^{\dagger}_n}{\partial \epsilon_{n}}
= \sum_{m=1}^{\infty} \frac{\left(-\ii \hat{H}_{n} dt^{(-)}\right)^m}{m!}
    \sum_{m^\prime=0}^{m-1}
    \hat{H}_{n}^{m^\prime}
    \hat{\mu}
    {\hat{H}}_{n}^{m-m^\prime-1}\,,
\end{equation}\]</p><p>with the recursive formula</p><p class="math-container">\[\begin{equation}
\begin{split}
|\chi^\prime(t_{n-1})⟩ &amp;= \sum_{m=1}^{\infty} \frac{\left(-\ii \, dt^{(-)}\right)^m}{m!} |\Phi_m⟩\,,\\
|\Phi_1⟩ &amp;= \hat{\mu} |\chi(t_n)⟩\,,              \\
|\Phi_m⟩ &amp;= \hat{\mu} {\hat{H}_{n}}^{\!\!m-1}  |\chi(t_n)⟩ + {\hat{H}_{n}} |\Phi_{m-1}⟩\,.
\end{split}
\end{equation}\]</p></div></div><p>For sufficiently small time steps, one may consider using only the first term in the Taylor series, <span>$|\chi^\prime_{kl}(t_{n-1})⟩ \approx -\ii dt_n^{(-)} |\Phi^{(lkn)}_1⟩$</span>. That is, from Eq. \eqref{eq:grad-via-chi-prime}, we get</p><p class="math-container">\[\begin{equation}
\begin{split}
\frac{\partial J_T}{\partial \epsilon_{nl}}
&amp;\approx 2\,dt_n\,\Im \sum_k \bigg \langle \chi_{kl}(t_{n}) \bigg\vert \frac{\partial \hat{H}_{kn}}{\partial \epsilon_{nl}} \bigg\vert \Psi_k(t_{n-1}) \bigg \rangle \\
&amp;\approx 2\,dt_n\,\Im \sum_k \bigg \langle \chi_{kl}(t_{n}) \bigg\vert \frac{\partial \hat{H}_{kn}}{\partial \epsilon_{nl}} \bigg\vert \Psi_k(t_{n}) \bigg \rangle\,.
\end{split}
\end{equation}\]</p><p>This approximation of the gradient has been used historically, including in GRAPE&#39;s original formulation [<a href="../references/#KhanejaJMR2005">1</a>], also because it matches optimality conditions derived in a Lagrange-multiplier formalism [<a href="../references/#PeircePRA1988">29</a>, <a href="../references/#BorziPRA2002">30</a>] that predates GRAPE. The derivation via Lagrange multipliers also extends more easily to equations of motion beyond Eq. \eqref{eq:tdse} such as the Gross–Pitaevskii equation [<a href="../references/#HohenesterPRA2007">31</a>, <a href="../references/#JaegerPRA2014">32</a>]. However, even though it is considered a &quot;gradient-type&quot; optimization, it is not considered to be within the scope of the <code>GRAPE</code> package (up to the ability to limit that Taylor expansion to first order). The conceptual difference is that these older methods (as well as the other &quot;gradient-type&quot;, <a href="https://juliaquantumcontrol.github.io/Krotov.jl/dev/">Krotov&#39;s method</a>) derive optimality conditions <em>first</em> (via functional derivatives), and then add time discretization to arrive at a numerical scheme. In contrast, <code>GRAPE</code> discretizes <em>first</em>, and then obtains gradients via simple derivatives w.r.t. the pulse values <span>$\epsilon_{nl}$</span>. This concept of &quot;discretize first&quot; is <em>the</em> core concept exploited in <code>GRAPE.jl</code>.</p><p>After GRAPE&#39;s original formulation [<a href="../references/#KhanejaJMR2005">1</a>], it was quickly realized that high-precision gradients are essential for numerical stability and convergence, in particular if the gradient is then used in a quasi-Newton method [<a href="../references/#FouquieresJMR2011">2</a>, <a href="../references/#KuprovJCP2009">22</a>]. Thus, low-order Taylor expansions should be avoided in most contexts.</p><h3 id="Overview-Gradgen"><a class="docs-heading-anchor" href="#Overview-Gradgen">Gradient Generators</a><a id="Overview-Gradgen-1"></a><a class="docs-heading-anchor-permalink" href="#Overview-Gradgen" title="Permalink"></a></h3><p>In order to evaluate Eq. \eqref{eq:U-deriv} to high precision, one can use a trick from computational linear algebra [<a href="../references/#VanLoanITAC1978">33</a>] that was reformulated in the context of quantum control by <a href="../references/#GoodwinJCP2015">Goodwin and Kuprov [5]</a>. It allows to calculate <span>$|\chi^\prime_{kl}(t_{n-1})⟩ \equiv \frac{\partial \hat{U}^{\dagger(k)}_n}{\partial \epsilon_{nl}} |\chi_k(t_n)⟩$</span> and <span>$|\chi_{kl}(t_{n-1})⟩ = \hat{U}^{\dagger(k)}_n |\chi_k(t_n)⟩$</span> at the same time, as</p><p class="math-container">\[\begin{equation}\label{eq:gradprop-bw}
  \begin{pmatrix} |\chi^{\prime}_{k1}(t_{n-1})⟩ \\ \vdots \\ |\chi^{\prime}_{kL}(t_{n-1})⟩ \\ |\chi_k(t_{n-1})⟩ \end{pmatrix}
  = \exp \left[-\ii\,G[\hat{H}_{kn}^{\dagger}]\,dt_n\right] |\tilde\chi_k(t_n)⟩
  \,,\\
\end{equation}\]</p><p>by backward-propagating an extended state</p><p class="math-container">\[\begin{equation}\label{eq:gradgen-state}
    |\tilde\chi_k(t_n)⟩
    \equiv \begin{pmatrix} 0 \\ \vdots \\ 0 \\ |\chi_k(t_n)⟩ \end{pmatrix}
\end{equation}\]</p><p>of dimension <span>$N(L+1)$</span>, where <span>$L$</span> is the number of controls and <span>$N$</span> is the dimension of <span>$|\chi_k⟩$</span>, under a &quot;gradient generator&quot;</p><p class="math-container">\[\begin{equation}\label{eq:gradgen}
    G[\hat{H}_{kn}^{\dagger}]
    = \begin{pmatrix}
        \hat{H}^\dagger_{kn} &amp; 0 &amp; \dots &amp; 0 &amp;\hat{\mu}_{1kn}^{\dagger} \\
        0 &amp; \hat{H}^\dagger_{kn} &amp; \dots &amp; 0 &amp; \hat{\mu}_{2kn}^{\dagger} \\
        \vdots &amp; &amp; \ddots &amp; &amp; \vdots \\
        0 &amp; 0 &amp; \dots &amp; \hat{H}^\dagger_{kn} &amp; \hat{\mu}_{Lkn}^{\dagger} \\
        0 &amp; 0 &amp; \dots &amp; 0 &amp; \hat{H}^\dagger_{kn}
    \end{pmatrix}\,.
\end{equation}\]</p><p>This is a purely formal way of writing the gradient generator; in practice, the extended state <span>$|\tilde\chi_k(t_n)⟩$</span> is represented by a data structure with slots for the states <span>$|\chi^{\prime}_{1}⟩$</span> … <span>$|\chi^{\prime}_{L}⟩$</span>, in addition to the original state <span>$|\chi⟩$</span>, and <span>$G[\hat{H}_{kn}^{\dagger}]$</span> is a container around all the operators <span>$\hat{\mu}^{\dagger}_{lkn} \equiv \frac{\partial \hat{H}^{\dagger}_{kn}}{\partial \epsilon_{nl}}$</span> in addition to the original (adjoint) Hamiltonian or Liouvillian <span>$\hat{H}^{\dagger}_{kn}$</span> itself. The gradient generator <span>$G$</span> is then implicitly defined by how it acts on the extended state,</p><p class="math-container">\[\begin{equation}
    G[\hat{H}] \begin{pmatrix}
        |\chi^{\prime}_{1}⟩ \\ \vdots \\ |\chi^{\prime}_{L}⟩ \\ |\chi⟩
    \end{pmatrix}
    = \begin{pmatrix}
        \hat{H} |\chi^{\prime}_{1}⟩ + \hat{\mu}_1 |\chi⟩ \\
        \vdots \\
        \hat{H} |\chi^{\prime}_{L}⟩ + \hat{\mu}_L |\chi⟩ \\
        \hat{H} |\chi⟩
    \end{pmatrix}\,.
\end{equation}\]</p><p>This way, <span>$G[\hat{H}^{\dagger}_{kn}]$</span> replaces <span>$\hat{H}^{\dagger}_{kn}$</span> in the backwards propagation, using any of the methods in <a href="https://juliaquantumcontrol.github.io/QuantumPropagators.jl/dev/"><code>QuantumPropagators</code></a>, e.g., the polynomial Chebychev propagator. The appropriate data structures for <span>$G$</span> and the extended states are implemented in <a href="https://github.com/JuliaQuantumControl/QuantumGradientGenerators.jl">the <code>QuantumGradientGenerators</code> package</a>. As it provides an &quot;exact&quot; gradient independently of the time step, the use of the gradient generator is the default in <code>GRAPE.jl</code>, or it can be explicitly requested with <code>gradient_method=:gradgen</code>.</p><h2 id="GRAPE-scheme"><a class="docs-heading-anchor" href="#GRAPE-scheme">GRAPE scheme</a><a id="GRAPE-scheme-1"></a><a class="docs-heading-anchor-permalink" href="#GRAPE-scheme" title="Permalink"></a></h2><p>With Eq. \eqref{eq:grad-at-T-U} and the <a href="#Overview-Gradgen">use of gradient generators</a> explained above, we end up with an efficient numerical scheme for evaluating the full gradient shown in <a href="#fig-grape-scheme">Fig. 1</a>.</p><p id="fig-grape-scheme" style="text-align: center">
<a href="../fig/grape_scheme.png">
<img src="../fig/grape_scheme.png" width="100%"/>
</a>
<a href="#fig-grape-scheme">Figure 1</a>: Numerical scheme for the evaluation of the gradient in <code>GRAPE.jl</code>.
</p><p>In each iteration, we start in the bottom left with the initial state <span>$|\Psi_k(t=t_0=0)⟩$</span> for the <span>$k&#39;th$</span> trajectory. This state is forward-propagated under the guess pulse (in parallel for the different trajectories) over the entire time grid until final time <span>$T$</span> with <span>$N_T$</span> time steps. In the diagram, <span>$t_{-n}$</span> is a shorthand for <span>$t_{N_T - n}$</span>. The propagation over the <span>$n$</span>&#39;th time interval uses the pulse values <span>$\epsilon_{nl}$</span>. In the diagram, we have omitted the index <span>$l$</span> for the different control functions <span>$\epsilon_l(t)$</span> (<a href="#tmidr">TMIDR</a>). All of the forward-propagated states (red in the diagram) must be stored in memory.</p><p>Having determined <span>$|\Psi_k(T)⟩$</span>, the state <span>$|\chi_k(T)⟩$</span> is calculated according to Eq. \eqref{eq:chi} for each trajectory <span>$k$</span>. With the default <code>gradient_method=:gradgen</code> that is depicted here, <span>$|\chi_k(T)⟩$</span> is then converted into a zero-padded extended state <span>$|\tilde\chi_k(T)⟩$</span>, see Eq. \eqref{eq:gradgen-state}, which is then backward propagated under a gradient-generator <span>$G[\hat{H}_{kn}^{\dagger}]$</span> defined according to Eq. \eqref{eq:gradgen}.</p><p>After each step in the backward propagation, the extended state <span>$|\tilde\chi_k(t_n)\rangle⟩$</span> contains the gradient-states <span>$|\chi^{\prime}_{kl}(t_n)⟩$</span>, cf. Eq. \eqref{eq:gradprop-bw}. The corresponding forward-propagated states <span>$\Psi_k(t_n)$</span> are read from storage; the overlap <span>$⟨\chi^{\prime}_{kl}(t_n)|\Psi_k(t_n)⟩$</span> then contributes to the element <span>$(\nabla J)_{nl}$</span> of the gradient, cf. Eq. \eqref{eq:grad-via-chi-prime}. Note that <span>$|\tilde\chi_k(t_n)\rangle⟩$</span> must be reset in each time set, i.e., the components <span>$|\chi^{\prime}_{kl}(t_n)⟩$</span> must be zeroed out.</p><p>In the original formulation of GRAPE [<a href="../references/#KhanejaJMR2005">1</a>], <span>$|\chi_k(T)⟩$</span> is always the target state associated with the <span>$k$</span>&#39;th trajectory. This makes it arbitrary whether to forward-propagate (and store) <span>$|\Psi_k(t)⟩$</span> first, or backward-propagate (and store) <span>$|\chi_k(t)⟩$</span> first. However, with the generalization to arbitrary functionals [<a href="../references/#GoerzQ2022">3</a>] via the definition in Eq. \eqref{eq:chi}, <span>$|\chi_k(T)⟩$</span> can now depend on the forward-propagated states <span>$\{|\Psi_k(T)⟩\}$</span>. Thus, the forward propagation and storage must always precede the backward propagation. The requirement for storing the forward-propagated states also explains the choice to let <span>$\frac{\partial \hat{U}_n^{(k)}}{\partial \epsilon_{nl}}$</span> act to the left in Eq. \eqref{eq:grad-at-T-U} to get Eq. \eqref{eq:grad-via-chi-prime}. If we had instead chosen to let the derivative act to the right to get Eq. \eqref{eq:grad-via-psi-prime}, we would have to store all of the states <span>$|\Psi^{\prime}_k(t_{n})⟩$</span> in addition to just <span>$|\Psi_k(t_{n})⟩$</span> for every time step, which would increase the required memory <span>$L$</span>-fold for <span>$L$</span> controls.</p><p>The above scheme may be further augmented for <a href="#Overview-Running-Costs">running costs</a>. Also, if the alternative <code>gradient_method=:taylor</code> is used, the backward propagation is of the normal states <span>$|\chi_k(T)⟩$</span> instead of the extended <span>$|\chi_k(T)⟩$</span>, but the <span>$|\chi^{\prime}_{kl}(t_n)⟩$</span> still have to be evaluated in each time step. In any case, once the full gradient vector has been collected, it is passed to an <a href="#Optimizers">optimizer such as L-BFGS-B</a>.</p><h2 id="Overview-SemiAD"><a class="docs-heading-anchor" href="#Overview-SemiAD">Semi-automatic differentiation</a><a id="Overview-SemiAD-1"></a><a class="docs-heading-anchor-permalink" href="#Overview-SemiAD" title="Permalink"></a></h2><p>For most functionals, the boundary condition for the backward propagations, <span>$|\chi_k(T)⟩$</span> as defined in Eq. \eqref{eq:chi}, is straightforward to calculate analytically, using basic matrix calculus and Wirtinger derivatives, as in the example in the <a href="#Wirtinger-Vectors">Derivative w.r.t. complex vectors</a>. In such cases, a function that constructs the states <span>$|\chi_k(T)⟩$</span> from the forward-propagated states and information in the <code>trajectories</code> should be implemented by hand, and either passed explicitly to <a href="../api/#QuantumControl.optimize-Tuple{Any, Val{:GRAPE}}"><code>QuantumControl.optimize</code></a> as <code>chi</code>, or associated with the function passed as <code>J_T</code> by implementing a custom method for <code>QuantumControl.Functionals.make_analytic_chi</code>, see the Tip in <a href="https://juliaquantumcontrol.github.io/QuantumControl.jl/dev/api/reference/#QuantumControl.Functionals.make_chi"><code>QuantumControl.Functionals.make_chi</code></a> for details.</p><p>In other situations, the derivative might be overly cumbersome [<a href="../references/#WattsPRA2015">20</a>, <a href="../references/#GoerzPRA2015">21</a>], or completely non-analytical [<a href="../references/#KrausPRA2001">19</a>]. In such cases, the <span>$|\chi_k(T)⟩$</span> may be obtained via <a href="https://en.wikipedia.org/wiki/Automatic_differentiation">automatic differentiation</a> [<a href="../references/#GoerzQ2022">3</a>] (AD). <code>GRAPE.jl</code> supports this via the <a href="https://juliaquantumcontrol.github.io/QuantumControl.jl/dev/api/reference/#QuantumControl.Functionals.make_chi"><code>QuantumControl.Functionals.make_chi</code></a> function with <code>mode=:automatic</code>. There is no restriction to a particular AD Framework. Any supported framework like <a href="https://github.com/FluxML/Zygote.jl"><code>Zygote</code></a> can be loaded and passed to <code>make_chi</code> via the <code>automatic</code> argument, see <a href="https://juliaquantumcontrol.github.io/QuantumControl.jl/dev/api/reference/#QuantumControl.set_default_ad_framework"><code>QuantumControl.set_default_ad_framework</code></a>.</p><p>The AD overhead of evaluating <code>J_T</code> should be extremely minimal (negligible compared to the numerical cost of the backward and forward propagations), but it can be further simplified with analytic chain rules [<a href="../references/#GoerzQ2022">3</a>]:</p><ul><li><p>For functionals that depend on overlaps <span>$\tau_k \equiv ⟨\Psi_k^{\text{tgt}}|\Psi_k(T)⟩$</span>, <code>GRAPE.jl</code> supports a keyword argument <code>tau</code> in <code>J_T</code>. If the function that is passed as <code>J_T</code> supports the <code>tau</code> keyword argument, and if all elements of <code>problem.trajectories</code> have a defined <code>target_state</code>, then a value of complex values <code>tau</code> is passed as defined above.</p><p>Eq. \eqref{eq:chi} then becomes</p><p class="math-container">\[\begin{equation}
\label{eq:chi_tau}
|\chi_k(T)⟩
= -\frac{\partial J_T}{\partial \bra{\Psi_k(T)}}
= - \left(
    \frac{\partial J_T}{\partial \tau_k^*} \;
    \frac{\partial \tau_k^*}{\partial \bra{\Psi_k(T)}}
\right)
= -\frac{1}{2} \left(\,\nabla_{\tau_k} J_T \right) |\Psi_k^{\text{tgt}}⟩\,,
\end{equation}\]</p><p>where we have used that only the complex conjugate <span>$\tau_k^* = ⟨ \Psi_k(T)|\Psi_k^{\text{tgt}}⟩$</span> of the overlap depends explicitly on the co-state <span>$\bra{\Psi_k(T)}$</span>. The gradient <span>$\nabla_{\tau_k} J_T$</span> defined as in Eq. \eqref{eq:wirtinger-zygote-grad} — <a href="#Complex-Gradient">note the factor <span>$\frac{1}{2}$</span></a> — can be obtained with automatic differentiation.</p><p>When calling <a href="https://juliaquantumcontrol.github.io/QuantumControl.jl/dev/api/reference/#QuantumControl.Functionals.make_chi"><code>QuantumControl.Functionals.make_chi</code></a> with <code>mode=:automatic</code> and <code>via=:tau</code>, the above chain rule is used automatically to simplify the AD.</p></li><li><p>For the optimization of quantum gates, it is common to have a logical subspace embedded in a larger physical subspace. The functional <span>$J_T$</span> in this case can often be written as a function of the achieved gate <span>$\hat{U}_{L}$</span> in the logical subspace, a complex matrix with elements</p><p class="math-container">\[\begin{equation}%
  \label{eq:gate_definition}
  (\hat{U}_{L})_{ij} = \Braket{\phi_i | \Psi_j(T)}
  \quad \Leftrightarrow \quad
  (\hat{U}_{L})^{*}_{ij} = \Braket{\Psi_j(T) | \phi_i}\,,
\end{equation}\]</p><p>where <span>$|\phi_i⟩$</span> are the logical basis states, assumed to also be the initial states <span>$|\Psi_k(t=0)⟩ = |\phi_k⟩$</span> for the forward propagation (i.e., the optimization is defined with one trajectory per basis state).</p><p>Applying a further chain rule w.r.t. <span>$(\hat{U}_{L})_{ij}$</span> in Eq. \eqref{eq:chi}, we find</p><p class="math-container">\[\begin{equation}%
  \label{eq:chi-gate-proto}
  |\chi_k(T)⟩
  \equiv - \frac{\partial J_T}{\partial \bra{\Psi_k(T)}}
   = - \sum_{ij}
      \frac{\partial J_T}{\partial\,(U_{L})^{*}_{ij}}
      \frac{\partial\,(U_{L})^{*}_{ij}}{\partial \bra{\Psi_k(T)}}\,,
\end{equation}\]</p><p>again using the notation of the Wirtinger derivative. We have used that only <span>$(U_{L})^{*}_{ij}$</span> depends explicitly on the co-states <span>$\{\bra{\Psi_k(T)}\}$</span>. Furthermore,</p><p class="math-container">\[\begin{equation}
  \frac{\partial J_T}{\partial\,(U_{L})^{*}_{ij}}
  = \frac{1}{2} (\nabla_{U_{L}} J_T)_{ij}
\end{equation}\]</p><p>according to the definitions in Eqs. (\ref{eq:complex-gradient}, \ref{eq:wirtinger2}), and</p><p class="math-container">\[\begin{equation}
  \frac{\partial\,(U_{L})^{*}_{ij}}{\partial \bra{\Psi_k(T)}}
  = \frac{\partial}{\partial \bra{\Psi_k(T)}} \Braket{\Psi_j(T) | \phi_i}
  = \delta_{jk} |\phi_i⟩
\end{equation}\]</p><p>with the Kronecker delta <span>$\delta_{jk}$</span>. Thus, Eq. \eqref{eq:chi-gate-proto} simplifies to</p><p class="math-container">\[\begin{equation}%
  \label{eq:chi_gate}
  |\chi_k(T)⟩
  = -\frac{1}{2} \sum_i
    (\nabla_{U_{L}} J_T)_{ik} |\phi_i⟩\,,
\end{equation}\]</p><p>where <span>$\nabla_{U_{L}} J_T$</span> is evaluated via automatic differentiation, e.g. with the <a href="https://fluxml.ai/Zygote.jl/dev/#Zygote.gradient"><code>Zygote.gradient</code></a> function.</p><p>The <a href="https://juliaquantumcontrol.github.io/QuantumControl.jl/dev/api/reference/#QuantumControl.Functionals.gate_functional"><code>QuantumControl.Functionals.gate_functional</code></a> function can be used to construct functionals defined on top of a gate <span>$\hat{U}_L$</span>, and <a href="https://juliaquantumcontrol.github.io/QuantumControl.jl/dev/api/reference/#QuantumControl.Functionals.make_gate_chi"><code>QuantumControl.Functionals.make_gate_chi</code></a> constructs the equivalent <code>chi</code> function via AD and the above chain rule.</p></li></ul><h2 id="Overview-Running-Costs"><a class="docs-heading-anchor" href="#Overview-Running-Costs">Running costs</a><a id="Overview-Running-Costs-1"></a><a class="docs-heading-anchor-permalink" href="#Overview-Running-Costs" title="Permalink"></a></h2><p>So far, we have only discussed the evaluation of gradients for final-time functionals <span>$J_T$</span>. We now extend the discussion of semi-automatic differentiation to the running costs <span>$g_{a,b}$</span> in Eq. \eqref{eq:grape-functional}. Since we are considering piecewise constant pulses, the integral over the running cost turns into a sum over the time steps. That is, we rewrite Eq. \eqref{eq:grape-functional} as</p><p class="math-container">\[\begin{equation}%
  \label{eq:functional-discrete}
  J(\{\epsilon_{nl}\})
  =
  J_T(\{|\Psi_k(T)⟩\}) +
  \lambda_a \sum_{n=1}^{N_T} \sum_l (g_a)_{nl} +
  \lambda_b \sum_{n=0}^{N_T} (g_b)_{n}\,,
\end{equation}\]</p><p>with</p><p class="math-container">\[\begin{equation}
  (g_a)_{nl} = \frac{1}{dt_n} g_a(\epsilon_{nl}, dt_n)\,,\qquad
  (g_b)_{n} = \frac{1}{\Delta t_n} g_b(\{|\Psi_k(t_n)⟩\}, t_n)\,.
\end{equation}\]</p><p>As in Eq. \eqref{eq:psi-time-evolution}, we define <span>$|\Psi_k(t_n)⟩ = \hat{U}^{(k)}_n \dots \hat{U}^{(k)}_1 |\Psi_k(t=0)⟩$</span>, with the time grid points <span>$t_0 = 0$</span>, <span>$t_{N_T} = T$</span>, and with <span>$\hat{U}^{(k)}_n = \exp[-i \hat{H}_{kn} dt_n]$</span> as the time evolution operator for the <span>$n$</span>&#39;th time interval, <span>$dt_n = t_{n} - t_{n-1}$</span>. Similarly, <span>$\Delta t_n$</span> is the time step around the time grid point <span>$t_n$</span>, e.g. <span>$\Delta t_0 = dt_1$</span>, <span>$\Delta t_n = \frac{1}{2}(t_{n+1} - t_{n-1})$</span> for <span>$1\le n &lt; N_T$</span>, and <span>$\Delta t_{N_T} = dt_{N_T}$</span>. For uniform time grids, <span>$dt_n \equiv \Delta t_n \equiv dt$</span>.</p><h3 id="Field-dependent-running-costs"><a class="docs-heading-anchor" href="#Field-dependent-running-costs">Field-dependent running costs</a><a id="Field-dependent-running-costs-1"></a><a class="docs-heading-anchor-permalink" href="#Field-dependent-running-costs" title="Permalink"></a></h3><p>Typically, running costs on the control fields are direct analytic expressions, e.g., <span>$g_a(\{\epsilon_{nl}\}) = \epsilon_{nl}^2$</span> to penalize large amplitudes. Thus, they are easily included in the gradient, e.g., <span>$(\nabla g_a)_{nl} = 2 \epsilon_{nl}$</span>. For convenience, this can also be done with automatic differentiation. This even extends to penalties on the first and second derivatives of the controls [<a href="../references/#LeungPRA2017">23</a>–<a href="../references/#AbdelhafezPRA2020">25</a>].</p><p>In <code>GRAPE.jl</code>, running costs are enabled by passing a <code>J_a</code> function together with <code>lambda_a</code> to <a href="https://juliaquantumcontrol.github.io/QuantumControl.jl/dev/api/reference/#QuantumControl.optimize"><code>QuantumControl.optimize</code></a> with <code>method=GRAPE</code>. The optimization also needs a function <code>grad_J_a</code> which can be obtained automatically, see <a href="https://juliaquantumcontrol.github.io/QuantumControl.jl/dev/api/reference/#QuantumControl.Functionals.make_grad_J_a"><code>QuantumControl.Functionals.make_grad_J_a</code></a>.</p><h3 id="State-Dependent-Running-Costs"><a class="docs-heading-anchor" href="#State-Dependent-Running-Costs">State-dependent running costs</a><a id="State-Dependent-Running-Costs-1"></a><a class="docs-heading-anchor-permalink" href="#State-Dependent-Running-Costs" title="Permalink"></a></h3><p>More interesting is the case of state-dependent constraints. Typical examples [<a href="../references/#SchirmerNJP2011">34</a>] include trajectory optimizations,</p><p class="math-container">\[\begin{equation}
  g_{b,\text{trj}}(\{|\Psi_k(t_n)⟩\})
  = \sum_k \norm{|\Psi_k(t_n)⟩ - |\Psi^{\text{tgt}}_k(t_n)⟩}^2\,,
\end{equation}\]</p><p>where the time evolution of each state <span>$|\Psi_k(t_n)⟩$</span> should be close to some target evolution <span>$|\Psi^{\text{tgt}}_k(t_n)⟩$</span>, or observable optimizations</p><p class="math-container">\[\begin{equation}
  g_{b,\hat{D}(t)}(\{|\Psi_k(t_n)⟩\})
  = \sum_k \Braket{\Psi_k(t_n) | \hat{D}(t_n)| \Psi_k(t_n)}\,,
\end{equation}\]</p><p>where the expectation value of some observable <span>$\hat{D}(t)$</span> is to be minimized. A special case of this is the minimization of the population in some forbidden subspace [<a href="../references/#PalaoPRA2008">35</a>], where <span>$\hat{D}(t_n) \equiv \hat{D}$</span> is a projector into that subspace.</p><p>To obtain the full gradient of a functional with a state-dependent running cost, we apply the same procedure as in the section about <a href="#Gradients-for-final-time-functionals">Gradients for final-time functionals</a> and find</p><p class="math-container">\[  \begin{align}
    \frac{\partial J}{\partial \epsilon_{nl}}
    &amp;=
    2 \Re \sum_k \left[
      \frac{\partial J_T}{\partial |\Psi_k(T)⟩}
      \frac{\partial |\Psi_k(T)⟩}{\partial \epsilon_{nl}}
      + \sum_{n&#39;=0}^{N_T}
      \frac{\partial\,(g_b)_{n&#39;}}{\partial |\Psi_k(t_{n&#39;})⟩}
      \frac{\partial |\Psi_k(t_{n&#39;})⟩}{\partial \epsilon_{nl}}
    \right] \\
    \label{eq:gradJ-rc2}
    &amp;=
    -2 \Re \sum_k \frac{\partial}{\partial \epsilon_{nl}} \left[
      \bigg\langle \chi_{k}^{(0)}(T) \bigg\vert \hat{U}_{N_T} \dots \hat{U}_1 \bigg\vert \Psi_k(0) \bigg\rangle
     + \sum_{n&#39;=n}^{N_T}
        \bigg\langle \xi_{k}(t_{n&#39;}) \bigg\vert \hat{U}_{n&#39;} \dots \hat{U}_1 \bigg\vert \Psi_k(0) \bigg\rangle
    \right]
  \end{align}\]</p><p>with</p><p class="math-container">\[\begin{equation}%
  \label{eq:chi-boundary-gb1}
  |\chi_k^{(0)}(T)⟩ \equiv - \frac{\partial J_T}{\partial \bra{\Psi_k(T)}}\,,
  \qquad
  |\xi_k(t_{n&#39;})⟩ \equiv - \frac{\partial\,(g_b)_{n&#39;}}{\partial \bra{\Psi_k(t_{n&#39;})}}\,,
\end{equation}\]</p><p>cf. Eq. \eqref{eq:chi}. In the sum over <span>$n&#39;$</span> in Eq. \eqref{eq:gradJ-rc2}, we have used that <span>$|\Psi_k(t_{n&#39;})⟩$</span> depends on <span>$\epsilon_{nl}$</span> only for <span>$n&#39; \ge n$</span>. This implies that for the final time interval, <span>$n = N_T$</span>, there is only a single term,</p><p class="math-container">\[\begin{equation}
    \frac{\partial J}{\partial \epsilon_{N_T l}}
    = -2 \Re \sum_k \bigg\langle
      \chi_k(T) \bigg\vert
      \frac{\partial\hat{U}_{N_T}}{\partial \epsilon_{N_T l}}  \bigg\vert
      \Psi_k(t_{N_T-1})
    \bigg\rangle\,,
\end{equation}\]</p><p>with</p><p class="math-container">\[\begin{equation}\label{eq:chi-boundary-gb}
  |\chi_k(T)⟩
  \equiv
  |\chi_k^{(0)}(T)⟩ + |\xi_k(T)⟩
  =
  - \left(
    \frac{\partial J_T}{\partial \bra{\Psi_k(T)}} +
    \frac{\partial\,(g_b)_{N_T}}{\partial \bra{\Psi_k(T)}}
  \right)
  \,.
\end{equation}\]</p><p>Evaluating the gradient progressively backward in time for <span>$n = (N_T-1) \dots 1$</span>, we then find a recursive relationship</p><p class="math-container">\[\begin{equation}\label{eq:grape-gb-bw-eqm}
  \frac{\partial J}{\partial \epsilon_{nl}}
  = -2 \Re \sum_k \bigg\langle
    \chi_k(t_n) \bigg\vert
    \frac{\partial\hat{U}_{n}}{\partial \epsilon_{nl}}  \bigg\vert
    \Psi_k(t_{n-1})
  \bigg\rangle\,,
\end{equation}\]</p><p>with</p><p class="math-container">\[\begin{equation}\label{eq:chi-bw-gb}
  |\chi_k(t_n)⟩ =
    \hat{U}_{n+1}^\dagger |\chi_k(t_{n+1})⟩ -
    \frac{\partial\,(g_b)_{n}}{\partial \bra{\Psi_k(t_n)}}\,.
\end{equation}\]</p><p>Thus, there are no fundamental changes to the scheme in <a href="#fig-grape-scheme">Fig. 1</a> in the presence of state-dependent running costs. The states <span>$\{|\Psi_k(0)⟩\}$</span> must be forward-propagated and stored, and then the extended states <span>$|\tilde\chi_k(t_n)⟩$</span> are propagated backward to produce the gradient. The only difference is that the boundary state <span>$|\tilde\chi_k(T)⟩$</span> is now constructed based on Eq. \eqref{eq:chi-boundary-gb} instead of Eq. \eqref{eq:chi}. Furthermore, the backward propagation uses the discrete inhomogeneous Eq. \eqref{eq:chi-bw-gb}. The inhomogeneity is calculated using the forward-propagated states stored previously, with the derivative of <span>$g_b$</span> performed analytically or by automatic differentiation.</p><div class="admonition is-warning" id="Warning-fa93384587f01f15"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-fa93384587f01f15" title="Permalink"></a></header><div class="admonition-body"><p>Support for state-dependent running costs is planned for a future version of <code>GRAPE.jl</code>; currently, there are no parameters to pass for <code>g_b</code>, <code>lambda_a</code>, etc.</p></div></div><h2 id="Optimizers"><a class="docs-heading-anchor" href="#Optimizers">Optimizers</a><a id="Optimizers-1"></a><a class="docs-heading-anchor-permalink" href="#Optimizers" title="Permalink"></a></h2><p>In the preceding sections, we have discussed in detail the GRAPE method for obtaining the gradient <span>$(\nabla J)_{nl} \equiv \frac{\partial J}{\partial \epsilon_{nl}}$</span> that determines how much the optimization functional <span>$J$</span> changes with variations of the <span>$nl$</span>&#39;th element of a vector of pulse values, i.e., the value of the control function <span>$\epsilon_l(t)$</span> on the <span>$n$</span>&#39;th interval of the time grid (under the fundamental assumption that <span>$\epsilon_l(t)$</span> is discretized to be piecewise constant.</p><p>In the original formulation of GRAPE, the values <span>$\epsilon_{nl}$</span> would then be updated in each iteration by taking a step with a fixed step width <span>$\alpha$</span> in the direction of the negative gradient [<a href="../references/#KhanejaJMR2005">1</a>, cf. Eq. (13)]</p><p class="math-container">\[\begin{equation}\label{eq:gradient-descent-update}
\epsilon_{nl} \rightarrow \epsilon_{nl} - \alpha (\nabla J)_{nl}
\end{equation}\]</p><p>In practice, the gradient can also be fed into an arbitrary gradient-based optimizer. These can include various linesearch methods to determine an optimal step width <span>$\alpha$</span>, avoiding slow convergence due to <span>$\alpha$</span> being too conservative, or overshooting the optimum with a value of <span>$\alpha$</span> that is too large. They can also include quasi-Newton methods, that determine a &quot;search direction&quot; different from <span>$\nabla J$</span> by using <span>$\nabla J$</span> to estimate a Hessian.</p><p><a href="../references/#FouquieresJMR2011">De Fouquières <em>et al.</em> [2]</a> showed that using the <a href="https://en.wikipedia.org/wiki/Broyden–Fletcher–Goldfarb–Shanno_algorithm">BFGS</a> quasi-Newton algorithm results in a dramatic improvement in stability and convergence. Following what is widely considered best practice, <code>GRAPE.jl</code> uses the memory-efficient L-BFGS-B [<a href="../references/#ZhuATMS1997">36</a>, <a href="../references/#LBFGSB_jl">37</a>] implementation as the default optimization backend. This method also allows including box constraints (hence the &quot;-B&quot; suffix) for the control values. In <a href="https://juliaquantumcontrol.github.io/QuantumControl.jl/dev/api/reference/#QuantumControl.optimize"><code>QuantumControl.optimize</code></a> with <code>method=GRAPE</code>, passing <code>lower_bound</code>, <code>upper_bound</code>, or (for more fine-tuned specifications), <code>pulse_options</code> with <code>lower_bounds</code> and <code>upper_bounds</code> vectors for the value of each control in each time interval allows using this box-constraint feature.</p><p>Even though <code>L-BFGS-B</code> is a remarkably robust and easy-to-use optimizer, <code>GRAPE.jl</code> also allows to use any of the gradient-based optimizers in the <a href="https://julianlsolvers.github.io/Optim.jl/stable/"><code>Optim</code> toolbox</a>. This includes the <a href="https://julianlsolvers.github.io/Optim.jl/stable/algo/gradientdescent/#Gradient-Descent">Gradient Descent</a> of Eq. \eqref{eq:gradient-descent-update}, potentially with the addition of a <a href="https://julianlsolvers.github.io/Optim.jl/stable/algo/linesearch/#Line-search">line search</a>. Any suitable optimizer from <code>Optim</code> (with its own options for, e.g., the line search) can be passed to <a href="https://juliaquantumcontrol.github.io/QuantumControl.jl/dev/api/reference/#QuantumControl.optimize"><code>QuantumControl.optimize</code></a> via the <code>optimizer</code> keyword.</p><div class="admonition is-warning" id="Warning-f9acbeb52d048be4"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-f9acbeb52d048be4" title="Permalink"></a></header><div class="admonition-body"><p>The details of how to pass options to <code>Optim</code> optimizers or how to query the state of the optimization are considered experimental. A future version of <code>GRAPE</code> may also adopt the more general <a href="https://github.com/SciML/Optimization.jl"><code>Optimization</code> interface</a>.</p></div></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../usage/">« Usage</a><a class="docs-footer-nextpage" href="../api/">API »</a><div class="flexbox-break"></div><p class="footer-message"><a href="https://github.com/JuliaQuantumControl/GRAPE.jl">GRAPE.jl</a> v0.7.5+dev docs <a href="https://creativecommons.org/licenses/by/4.0/deed.en">CC-BY-4.0</a>. Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Monday 14 July 2025 15:53">Monday 14 July 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
